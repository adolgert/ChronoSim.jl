<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · ChronoSim.jl</title><meta name="title" content="Introduction · ChronoSim.jl"/><meta property="og:title" content="Introduction · ChronoSim.jl"/><meta property="twitter:title" content="Introduction · ChronoSim.jl"/><meta name="description" content="Documentation for ChronoSim.jl."/><meta property="og:description" content="Documentation for ChronoSim.jl."/><meta property="twitter:description" content="Documentation for ChronoSim.jl."/><meta property="og:url" content="https://adolgert.github.io/ChronoSim.jl/intro/"/><meta property="twitter:url" content="https://adolgert.github.io/ChronoSim.jl/intro/"/><link rel="canonical" href="https://adolgert.github.io/ChronoSim.jl/intro/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ChronoSim.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">ChronoSim</a></li><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Core-scheduling-paradigm"><span>Core scheduling paradigm</span></a></li><li><a class="tocitem" href="#Event-proposal-generation"><span>Event proposal generation</span></a></li><li><a class="tocitem" href="#Automatic-dependency-inference"><span>Automatic dependency inference</span></a></li><li><a class="tocitem" href="#Put-it-together"><span>Put it together</span></a></li><li><a class="tocitem" href="#Challenges"><span>Challenges</span></a></li><li><a class="tocitem" href="#Advantages"><span>Advantages</span></a></li></ul></li><li><a class="tocitem" href="../not_chrono/">Why Not Hand Made</a></li><li><a class="tocitem" href="../whatitis/">What It Does</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../simulation_state/">Simulation State</a></li><li><a class="tocitem" href="../categorize/">Category of Simulation</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><span class="tocitem">Development</span><ul><li><a class="tocitem" href="../plan/">Plan</a></li><li><a class="tocitem" href="../event_update/">Event Updates</a></li><li><a class="tocitem" href="../architecture_diagram/">Architecture</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Home</a></li><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/ChronoSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/ChronoSim.jl/blob/main/docs/src/intro.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><h2 id="Core-scheduling-paradigm"><a class="docs-heading-anchor" href="#Core-scheduling-paradigm">Core scheduling paradigm</a><a id="Core-scheduling-paradigm-1"></a><a class="docs-heading-anchor-permalink" href="#Core-scheduling-paradigm" title="Permalink"></a></h2><p>Every simulation framework has a way to decide what events happen next, a core scheduling paradigm. For ChronoSim, every event has one rule for when it is eligible to happen, a <code>precondition</code>. Here&#39;s an example for a movement event.</p><pre><code class="language-julia hljs">function precondition(event::Move, state, time)
	loc = state.agents[event.agent].location
	return state.location[loc + event.direction] == 0
end</code></pre><p>As soon as that event returns <code>true</code>, the event becomes enabled, which means it will fire at a future time determined by a probability distribution. If that <code>precondition</code> later becomes <code>false</code>, the event becomes disabled. The precondition associated with an event determines whether it can fire, and the moment that&#39;s true, it calls <code>enable</code>.</p><pre><code class="language-julia hljs">function enable(event::Move, state, time)
	return (Weibull(2, 1.0), time)
end</code></pre><p>That tells the framework that the the time between enabling this event and firing it will follow a Weibull distribution.</p><h2 id="Event-proposal-generation"><a class="docs-heading-anchor" href="#Event-proposal-generation">Event proposal generation</a><a id="Event-proposal-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Event-proposal-generation" title="Permalink"></a></h2><p>It may sound like this framework checks the precondition for every event every time a previous event fires, but it is careful about when it checks preconditions. You have to provide an event with an event generator that proposes when a precondition could possibly be true.</p><pre><code class="language-julia hljs">@conditionsfor Move begin
	@reactto changed(agent[who].location) do state
		for direction in ALLDIRECTIONS
			generate(Move(who, direction))
		end
	end
end</code></pre><p>This event generator watches the state, in a subject-observer pattern, to see when an agent&#39;s location changed. In this example, the generator creates new possible events for that specific agent. The generator can be over-eager when it suggests possible events because each possible event&#39;s precondition will make the right call.</p><h2 id="Automatic-dependency-inference"><a class="docs-heading-anchor" href="#Automatic-dependency-inference">Automatic dependency inference</a><a id="Automatic-dependency-inference-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-dependency-inference" title="Permalink"></a></h2><p>The framework tracks how causality moves from event to event through the state. When an event fires, such as our Move event, it changes the state.</p><pre><code class="language-julia hljs">function fire!(event::Move, state, when, rng)
	state.location[state.agent[event.who].location] = 0
	state.agent[event.who].location += event.direction
	state.location[state.agent[event.who].location] = event.who
end</code></pre><p>Each time this <code>fire!</code> function sets a value in the state, the address of that part of the state is recorded, here <code>(:location, &lt;locindex&gt;)</code> and <code>(:agent, &lt;agentidx&gt;, :location)</code>. Any other event whose generator is listening for modifications at these addresses will generate relevant events.</p><p>Similarly, the framework watches each call to read the state during a <code>precondition()</code> in order to know which state changes should trigger a re-check on whether that <code>precondition()</code> remains true. The framework watches each call to an <code>enable()</code> to determine which changes of the state at a later time might require re-evaluating the rate of the distribution for when the event fires.</p><h2 id="Put-it-together"><a class="docs-heading-anchor" href="#Put-it-together">Put it together</a><a id="Put-it-together-1"></a><a class="docs-heading-anchor-permalink" href="#Put-it-together" title="Permalink"></a></h2><p>In order to define a single event in a system, you have to provide:</p><ul><li><p>An immutable struct for that event that derives from <code>ChronoSim.SimEvent</code>. This struct can be empty but usually contains integers, symbols, enums, or strings that identify actors and resources.</p></li><li><p>A generator that watches for changes to state or previously-fired events that indicate that this event might possible be enabled.</p></li><li><p>A precondition for this event.</p></li><li><p>An enabling rate, which returns a continuous, univariate distribution from Distributions.jl. There can be an optional re-enabling function defined if that&#39;s significantly different.</p></li><li><p>A <code>fire!</code> function to change the state when this event happens.</p></li></ul><h2 id="Challenges"><a class="docs-heading-anchor" href="#Challenges">Challenges</a><a id="Challenges-1"></a><a class="docs-heading-anchor-permalink" href="#Challenges" title="Permalink"></a></h2><ul><li><p>That&#39;s a lot to define if you&#39;re doing a simple simulation.</p></li><li><p>There isn&#39;t a slow-start learning curve for this.</p></li><li><p>If the simulation doesn&#39;t run as planned, there are lots of moving parts that could be wrong.</p></li><li><p>Maybe generating extra events is costly?</p></li></ul><p>This style of simulation has the same number of possible problems as other simulations, but they are more visible. You&#39;ll see it&#39;s easier to check correctness when the logic of discrete events is separated into the parts above.</p><p>The generation of extra events isn&#39;t any worse than a normal for-loop when you create a new event. It&#39;s just broken into a generator and a separate checker, so it feels like it costs more.</p><h2 id="Advantages"><a class="docs-heading-anchor" href="#Advantages">Advantages</a><a id="Advantages-1"></a><a class="docs-heading-anchor-permalink" href="#Advantages" title="Permalink"></a></h2><ul><li><p>Model checking. The set of preconditions defines what events should be enabled at any time in the simulation. Checking all preconditions is a great correctness check. The model itself also has a strong correspondence to TLA+ models.</p></li><li><p>Canceling ghost events. There are cases where firing one event makes another event no longer relevant. Some simulations deal with these ghost events by ignoring them later, but they can create confusion when an event is enabled, then ghosted, then should be enabled again. This simulation is clear about canceling events whose preconditions are no longer met.</p></li><li><p>Composition of models through the state dependencies. If you make a model of how people move and then a model of how disease spreads, you don&#39;t need to modify those models in order to compose them. Because each model&#39;s events are enabled by state changes, they will implicitly share resources correctly, where in this example the resources are the location and health states of people.</p></li><li><p>This framework can calculate log-likelihood for model-fitting and uncertainty quantification, Bayesian inference, and rare event simulation. It defines a stochastic process.</p></li></ul><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« ChronoSim</a><a class="docs-footer-nextpage" href="../not_chrono/">Why Not Hand Made »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 28 August 2025 14:07">Thursday 28 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
