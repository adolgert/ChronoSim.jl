var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-Started-with-ChronoSim.jl","page":"Getting Started","title":"Getting Started with ChronoSim.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is an example of using Literate.jl to create executable documentation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ChronoSim.jl is a simulation framework built on top of CompetingClocks.jl for event-driven simulations with dependency tracking.","category":"page"},{"location":"getting_started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First, let's import the package:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using ChronoSim","category":"page"},{"location":"getting_started/#Simple-Example","page":"Getting Started","title":"Simple Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here's how you would set up a basic simulation: (This is just an example structure - you'll replace this with actual working code)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"println(\"This is a placeholder example for Literate.jl integration\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is a placeholder example for Literate.jl integration\n","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"As you develop more examples, you can add them as .jl files in the literate_src/ directory. They will be automatically converted to markdown and included in the documentation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"#ChronoSim","page":"Home","title":"ChronoSim","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ChronoSim.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#ChronoSim.PhysicalState","page":"Home","title":"ChronoSim.PhysicalState","text":"PhysicalState is an abstract type from which to inherit the state of a simulation. A PhysicalState should put all mutable values, the values upon which events depend, into TrackedVector objects. For instance:\n\n@tracked_struct Square begin\n    occupant::Int\n    resistance::Float64\nend\n\n# Everything we know about an agent.\n@tracked_struct Agent begin\n    health::Health\n    loc::CartesianIndex{2}\nend\n\nmutable struct BoardState <: PhysicalState\n    board::TrackedVector{Square}\n    agent::TrackedVector{Agent}\nend\n\nThe PhysicalState may contain other properties, but those defined with TrackedVectors are used to compute the next event in the simulation.\n\n\n\n\n\n","category":"type"},{"location":"#ChronoSim.capture_state_changes-Tuple{Function, Any}","page":"Home","title":"ChronoSim.capture_state_changes","text":"capture_state_changes(f::Function, physical_state)\n\nThe callback function f will modify the physical state. This function records which parts of the state were modified. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"#ChronoSim.capture_state_reads-Tuple{Function, Any}","page":"Home","title":"ChronoSim.capture_state_reads","text":"capture_state_reads(f::Function, physical_state)\n\nThe callback function f will read the physical state. This function records which parts of the state were read. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"#ChronoSim.isconsistent-Tuple{PhysicalState}","page":"Home","title":"ChronoSim.isconsistent","text":"isconsistent(physical_state)\n\nA simulation in debug mode will assert isconsistent(physical_state) is true. Override this to verify the physical state of your simulation.\n\n\n\n\n\n","category":"method"},{"location":"#ChronoSim.over_generated_events-Tuple{Function, Vararg{Any, 4}}","page":"Home","title":"ChronoSim.over_generated_events","text":"over_generated_events(f::Function, generators, physical, fired_event_key, changed_places)\n\nGiven a fired event and the set of places changed by that event, create new events that may depend on that fired event and those changed places.\n\n\n\n\n\n","category":"method"},{"location":"#ChronoSim.over_tracked_physical_state-Union{Tuple{T}, Tuple{Function, T}} where T<:PhysicalState","page":"Home","title":"ChronoSim.over_tracked_physical_state","text":"over_tracked_physical_state(fcallback::Function, physical::PhysicalState)\n\nIterate over all tracked vectors in the physical state.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
