var documenterSearchIndex = {"docs":
[{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/#Core-scheduling-paradigm","page":"Introduction","title":"Core scheduling paradigm","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Every simulation framework has a way to decide what events happen next, a core scheduling paradigm. For ChronoSim, every event has one rule for when it is eligible to happen, a precondition. Here's an example for a movement event.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"function precondition(event::Move, state, time)\n\tloc = state.agents[event.agent].location\n\treturn state.location[loc + event.direction] == 0\nend","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"As soon as that event returns true, the event becomes enabled, which means it will fire at a future time determined by a probability distribution. If that precondition later becomes false, the event becomes disabled. The precondition associated with an event determines whether it can fire, and the moment that's true, it calls enable.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"function enable(event::Move, state, time)\n\treturn (Weibull(2, 1.0), time)\nend","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"That tells the framework that the the time between enabling this event and firing it will follow a Weibull distribution.","category":"page"},{"location":"intro/#Event-proposal-generation","page":"Introduction","title":"Event proposal generation","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It may sound like this framework checks the precondition for every event every time a previous event fires, but it is careful about when it checks preconditions. You have to provide an event with an event generator that proposes when a precondition could possibly be true.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"@conditionsfor Move begin\n\t@reactto changed(agent[who].location) do state\n\t\tfor direction in ALLDIRECTIONS\n\t\t\tgenerate(Move(who, direction))\n\t\tend\n\tend\nend","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This event generator watches the state, in a subject-observer pattern, to see when an agent's location changed. In this example, the generator creates new possible events for that specific agent. The generator can be over-eager when it suggests possible events because each possible event's precondition will make the right call.","category":"page"},{"location":"intro/#Automatic-dependency-inference","page":"Introduction","title":"Automatic dependency inference","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The framework tracks how causality moves from event to event through the state. When an event fires, such as our Move event, it changes the state.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"function fire!(event::Move, state, when, rng)\n\tstate.location[state.agent[event.who].location] = 0\n\tstate.agent[event.who].location += event.direction\n\tstate.location[state.agent[event.who].location] = event.who\nend","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Each time this fire! function sets a value in the state, the address of that part of the state is recorded, here (:location, <locindex>) and (:agent, <agentidx>, :location). Any other event whose generator is listening for modifications at these addresses will generate relevant events.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Similarly, the framework watches each call to read the state during a precondition() in order to know which state changes should trigger a re-check on whether that precondition() remains true. The framework watches each call to an enable() to determine which changes of the state at a later time might require re-evaluating the rate of the distribution for when the event fires.","category":"page"},{"location":"intro/#Put-it-together","page":"Introduction","title":"Put it together","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In order to define a single event in a system, you have to provide:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"An immutable struct for that event that derives from ChronoSim.SimEvent. This struct can be empty but usually contains integers, symbols, enums, or strings that identify actors and resources.\nA generator that watches for changes to state or previously-fired events that indicate that this event might possible be enabled.\nA precondition for this event.\nAn enabling rate, which returns a continuous, univariate distribution from Distributions.jl. There can be an optional re-enabling function defined if that's significantly different.\nA fire! function to change the state when this event happens.","category":"page"},{"location":"intro/#Challenges","page":"Introduction","title":"Challenges","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"That's a lot to define if you're doing a simple simulation.\nThere isn't a slow-start learning curve for this.\nIf the simulation doesn't run as planned, there are lots of moving parts that could be wrong.\nMaybe generating extra events is costly?","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This style of simulation has the same number of possible problems as other simulations, but they are more visible. You'll see it's easier to check correctness when the logic of discrete events is separated into the parts above.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The generation of extra events isn't any worse than a normal for-loop when you create a new event. It's just broken into a generator and a separate checker, so it feels like it costs more.","category":"page"},{"location":"intro/#Advantages","page":"Introduction","title":"Advantages","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Model checking. The set of preconditions defines what events should be enabled at any time in the simulation. Checking all preconditions is a great correctness check. The model itself also has a strong correspondence to TLA+ models.\nCanceling ghost events. There are cases where firing one event makes another event no longer relevant. Some simulations deal with these ghost events by ignoring them later, but they can create confusion when an event is enabled, then ghosted, then should be enabled again. This simulation is clear about canceling events whose preconditions are no longer met.\nComposition of models through the state dependencies. If you make a model of how people move and then a model of how disease spreads, you don't need to modify those models in order to compose them. Because each model's events are enabled by state changes, they will implicitly share resources correctly, where in this example the resources are the location and health states of people.\nThis framework can calculate log-likelihood for model-fitting and uncertainty quantification, Bayesian inference, and rare event simulation. It defines a stochastic process.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"plan/#Plan","page":"Plan","title":"Plan","text":"","category":"section"},{"location":"plan/#Current-Capabilities","page":"Plan","title":"Current Capabilities","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"<iframe src=\"assets/d3_event_diagram.html\" style=\"width: 100%; height: 500px; border: none;\"></iframe>","category":"page"},{"location":"plan/#Features","page":"Plan","title":"Features","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Rule-based events\nSampling methods\nDirac delta function times (for ODEs)\nDeterministic once random seed is set.\nRe-enabling of events\nRules that depend on events instead of just states.\nMacro and struct for event(key)\nObservers on events\nObservers of state changes\nImmediate events","category":"page"},{"location":"plan/#Examples","page":"Plan","title":"Examples","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Elevators with TLA+.\nReliability with a set of trucks.\nSIR with strain mutation and individual movement models.\nMovement through a 2D domain for particle filtering.","category":"page"},{"location":"plan/#Known-bugs","page":"Plan","title":"Known bugs","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Observe macro needs hygiene to evaluate methods in defining context.","category":"page"},{"location":"plan/#Future-Capabilities","page":"Plan","title":"Future Capabilities","text":"","category":"section"},{"location":"plan/#Features-2","page":"Plan","title":"Features","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Importance sampling\nPregeneration of all rule-based events.\nTransactional firing (for estimation of derivatives)\nMCMC sampling from trajectories","category":"page"},{"location":"plan/#Example-Simulations","page":"Plan","title":"Example Simulations","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Move, infect, age, birth.\nPolicy-driven movement.\nQueuing model.\nChemical equations.\nDrone search pattern with geometry.\nHMC for house-to-house infestation.\nJob shop problem.\nCars driving on a map.","category":"page"},{"location":"plan/#Example-Uses-of-Simulations","page":"Plan","title":"Example Uses of Simulations","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Hook into standard Julia analysis tools.\nSampling rare events.\nParameter fitting to world data.\nOptimization of parameters to minimize a goal function.\nHMC on trajectories to find a most likely event stream.\nPOMDP","category":"page"},{"location":"plan/#Performance-Questions","page":"Plan","title":"Performance Questions","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"How stable can I make the type system in the running simulation? It uses Events in places and tuples in others.\nThe TrackedEntry needs to be timed and gamed.\nCould the TrackedEntry be an N-dimensional array? Could each entry be an array? A dictionary?\nCan the main simulation look over the keys to determine types before it instantiates?\nThe depnet is absolutely wrong for the current main loop. It might be closer to right for another mainloop. Should try various implementations.\nMeasure performance with profiling. Look for the memory leaks.","category":"page"},{"location":"plan/#Improvements-to-the-Framework-User-Interface","page":"Plan","title":"Improvements to the Framework User Interface","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"This section is from conversations with AI about the spectrum of ways to improve the user interface. There were some good ideas in there so they are recorded here.","category":"page"},{"location":"plan/#generator-functions-use-do-function-syntax-so-make-it-easier.","page":"Plan","title":"generator functions use do-function syntax so make it easier.","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Create a macro for generator functions that looks like you call generate(event) but really calls a do-function callback underneath.","category":"page"},{"location":"plan/#Simplify-enabling/reenabling","page":"Plan","title":"Simplify enabling/reenabling","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Ask the simulation to define the distribution and when but not the sampler, rng, or clock_key.","category":"page"},{"location":"plan/#Explicitly-register-functions","page":"Plan","title":"Explicitly register functions","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"In framework.jl - automatic method generation   function registerevent(eventtype::Type{<:SimEvent}, spec::EventSpec)       # Generate precondition, generators, enable, fire! automatically       # Based on declarative specification   end","category":"page"},{"location":"plan/#Macro-to-say-what-generators-trigger-on","page":"Plan","title":"Macro to say what generators trigger on","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Framework provides path builder   @watches actors[].state  # Instead of [:actors, ℤ, :state]   @watches board[].occupant","category":"page"},{"location":"plan/#Put-common-event-patterns-into-template-structs","page":"Plan","title":"Put common event patterns into template structs","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Framework could provide base types:","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"ActorEvent{T} - for single-actor events\nInteractionEvent{T} - for multi-actor events\nScheduledEvent{T} - for time-based events\nStateTransitionEvent{T} - for state machine transitions","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"or make it a function:   Framework provides factory for common patterns   createstatetransitionevent(       :Break,       fromstate = :working,       tostate = :broken,       ratefield = :faildist,       agetracking = true   )","category":"page"},{"location":"plan/#Put-common-enabling-patterns-into-template-structs","page":"Plan","title":"Put common enabling patterns into template structs","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Common patterns built into framework   abstract type RateModel end   struct ConstantRate <: RateModel; dist; end   struct ActorRate <: RateModel; field::Symbol; end   struct TimeBasedRate <: RateModel; calc::Function; end","category":"page"},{"location":"plan/#Help-build-the-simulation-itself","page":"Plan","title":"Help build the simulation itself","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"In framework.jl   @simulation MySimulation begin       state_type = IndividualState       events = [StartDay, EndDay, Break, Repair]       sampler = CombinedNextReaction","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"  initialize = function(physical, rng)\n      # initialization code\n  end\n\n  stop_when = (physical, step, event, when) -> when > days","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"end","category":"page"},{"location":"plan/#Make-tools-with-which-to-make-simulation-DSLs","page":"Plan","title":"Make tools with which to make simulation DSLs","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # Framework should export these primitives\n  export create_generator, register_precondition, add_rate_function\n  export EventSpecification, GeneratorSpec, RateSpec\n\n  # So users can build their own DSLs:\n  macro my_reliability_event(name, spec)\n      quote\n          struct $(esc(name)) <: ActorEvent{IndividualState}\n              actor_idx::Int\n          end\n\n          # Use framework primitives\n          register_precondition($(esc(name)), $(spec.precondition))\n          add_rate_function($(esc(name)), $(spec.rate))\n      end\n  end","category":"page"},{"location":"plan/#Use-traits-more-than-inheritance","page":"Plan","title":"Use traits more than inheritance","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Maybe both traits and hooks, where a user registers a function to call for a particular event.","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # Framework defines traits\n  abstract type EventTrait end\n  struct HasActor <: EventTrait end\n  struct HasSchedule <: EventTrait end\n  struct HasInteraction <: EventTrait end\n\n  # Users can mix traits freely\n  event_traits(::Type{<:SimEvent}) = ()\n  event_traits(::Type{Break}) = (HasActor(), HasSchedule())\n\n  # Framework dispatches on traits\n  function generate_precondition(evt::Type{T}) where T\n      traits = event_traits(T)\n      # Compose behavior from traits\n  end","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"This could also help the functions on events.","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # Instead of storing functions, use traits\n  abstract type PreconditionTrait end\n  struct StateCheck{S} <: PreconditionTrait\n      required_state::S\n  end\n\n  struct EventConfig{P <: PreconditionTrait}\n      precondition_trait::P\n  end\n\n  # Fast dispatch\n  @inline function check_precondition(evt::ActorEvent, physical, ::StateCheck{S}) where S\n      physical.actors[evt.actor_idx].state == S\n  end","category":"page"},{"location":"plan/#Make-Syntax-Trees-Accessible","page":"Plan","title":"Make Syntax Trees Accessible","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # If framework uses macros, expose the AST\n  macro framework_helper(expr)\n      ast = parse_event_ast(expr)\n      # Let users transform it\n      transformed = apply_user_transforms(ast)\n      return generate_code(transformed)\n  end\n\n  # Users can register transforms\n  register_ast_transform!(my_reliability_transform)","category":"page"},{"location":"plan/#Macro-advice","page":"Plan","title":"Macro advice","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Macro Design Best Practices","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"AVOID These Patterns:","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # 1. Rigid syntax requirements\n  @framework_event name::Type = value  # Forces specific syntax\n\n  # 2. Closed evaluation contexts\n  @framework_event Break begin\n      eval(:(struct Break ... end))  # Evaluates in framework module\n  end\n\n  # 3. Monolithic macros\n  @define_entire_event Break working broken fail_dist ...","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"PREFER These Patterns:","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # 1. Composable macro fragments\n  @event_struct Break actor_idx::Int\n  @event_precondition Break (evt, phys) -> phys.actors[evt.actor_idx].state == working\n  @event_rate Break (evt, phys) -> phys.params[evt.actor_idx].fail_dist\n\n  # 2. Pass-through to user context\n  macro framework_helper(name, user_expr)\n      quote\n          # Evaluate in caller's context\n          local user_result = $(esc(user_expr))\n          framework_process($(QuoteNode(name)), user_result)\n      end\n  end\n\n  # 3. Metadata-based approach\n  @event_metadata Break begin\n      traits = [:actor_based, :state_transition]\n      watches = [:actors]\n      # Users can add custom metadata\n  end","category":"page"},{"location":"plan/#Sample-Implementation","page":"Plan","title":"Sample Implementation","text":"","category":"section"},{"location":"plan/#Of-a-framework-that-enables-user-DSLs","page":"Plan","title":"Of a framework that enables user DSLs","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # Framework provides:\n    module ChronoSim\n\n  # Low-level registration API\n  function register_event_type(T::Type, config::EventConfig)\n      # Store in global registry\n  end\n\n  # Composable specifications\n  # This should use parametric types\n  struct EventConfig{P,G,E,F}\n      precondition::Union{Function, Nothing}\n      generators::Vector{GeneratorSpec}\n      enable::Union{Function, Nothing}\n      fire::Union{Function, Nothing}\n      metadata::Dict{Symbol, Any}\n  end\n\n  # Give the parametric event config a solid constructor.\n  function actor_event_behavior(;\n      required_state::Symbol,\n      rate_field::Symbol,\n      fire_action::Function\n  )\n      EventBehavior(\n          # Specialized, inlinable functions\n          (evt, physical) -> getfield(physical.actors[evt.actor_idx], :state) == required_state,\n          (evt, sampler, physical, when, rng) -> enable!(\n              sampler,\n              clock_key(evt),\n              getfield(getfield(physical.params[evt.actor_idx], rate_field)),\n              when, when, rng\n          ),\n          fire_action,\n          default_actor_generators()\n      )\n  end\n\n  end # module\n\n  # User's DSL:\n  module ReliabilityDSL\n    using ChronoSim\n\n  macro reliability_event(name, from, to, rate_field)\n      quote\n          struct $(esc(name)) <: SimEvent\n              actor_idx::Int\n          end\n\n          config = actor_event_config(\n              precondition_state = $(esc(from)),\n              rate_distribution = evt -> evt.physical.params[evt.actor_idx].$rate_field,\n              fire_action = (evt, phys, when) -> begin\n                  phys.actors[evt.actor_idx].state = $(esc(to))\n                  # Custom reliability logic here\n              end\n          )\n\n          register_event_type($(esc(name)), config)\n      end\n  end\n\n  # Clean syntax for users\n  @reliability_event Break working broken fail_dist\n  @reliability_event Repair broken ready repair_dist\n\n  end # module","category":"page"},{"location":"plan/#Of-an-ActorEvent{T}","page":"Plan","title":"Of an ActorEvent{T}","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"  abstract type ActorEvent{T} <: SimEvent end\n\n  # Default implementation that concrete types can override\n  actor_index(evt::ActorEvent) = evt.actor_idx\n  actor_collection(::Type{<:ActorEvent{T}}) where T = :actors\n  actor_state_field(::Type{<:ActorEvent{T}}) where T = :state\n\n  # Generic precondition - can be overridden\n  function precondition(evt::E, physical) where E <: ActorEvent\n      actor_idx = actor_index(evt)\n      checkbounds(Bool, getfield(physical, actor_collection(E)), actor_idx) || return false\n\n      # Allow custom precondition logic\n      actor_precondition(evt, physical)\n  end\n\n  # Subtype must implement this\n  actor_precondition(evt::ActorEvent, physical) =\n      error(\"Must implement actor_precondition for $(typeof(evt))\")\n\n  # Generic generators for any ActorEvent\n  function generators(::Type{E}) where E <: ActorEvent{T} where T\n      collection = actor_collection(E)\n      state_field = actor_state_field(E)\n\n      return [\n          EventGenerator(\n              ToPlace,\n              [collection, ℤ, state_field],\n              function (f::Function, physical, actor)\n                  evt = try_create_event(E, actor, physical)\n                  !isnothing(evt) && f(evt)\n              end\n          )\n      ]\n  end\n\n  # Helper to create event if valid\n  try_create_event(::Type{E}, actor_idx, physical) where E <: ActorEvent = E(actor_idx)\n\n  # Generic enable with rate lookup\n  function enable(evt::E, sampler, physical, when, rng) where E <: ActorEvent\n      rate_dist = get_rate_distribution(evt, physical)\n      enable_time_args = get_enable_times(evt, physical, when)\n      enable!(sampler, clock_key(evt), rate_dist, enable_time_args..., rng)\n  end\n\n  # Default reenable delegates to enable\n  function reenable(evt::E, sampler, physical, first_enabled, curtime, rng) where E <: ActorEvent\n      rate_dist = get_rate_distribution(evt, physical)\n      reenable_time_args = get_reenable_times(evt, physical, first_enabled, curtime)\n      enable!(sampler, clock_key(evt), rate_dist, reenable_time_args..., rng)\n  end\n\n  # Subtype must implement rate lookup\n  get_rate_distribution(evt::ActorEvent, physical) =\n      error(\"Must implement get_rate_distribution for $(typeof(evt))\")\n\n  # Default time arguments\n  get_enable_times(evt::ActorEvent, physical, when) = (when, when)\n  get_reenable_times(evt::ActorEvent, physical, first_enabled, curtime) = (first_enabled, curtime)","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"And what it does to the simulation code:","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":" struct Break <: ActorEvent{IndividualState}\n      actor_idx::Int\n  end\n\n  # Only need to specify unique behavior\n  actor_precondition(evt::Break, physical) =\n      physical.actors[evt.actor_idx].state == working\n\n  get_rate_distribution(evt::Break, physical) =\n      physical.params[evt.actor_idx].fail_dist\n\n  # Custom time calculation for non-memoryless distributions\n  get_enable_times(evt::Break, physical, when) =\n      (when - physical.actors[evt.actor_idx].work_age, when)\n\n  function fire!(evt::Break, physical, when, rng)\n      physical.actors[evt.actor_idx].state = broken\n      started_work = physical.actors[evt.actor_idx].started_working_time\n      physical.actors[evt.actor_idx].work_age += when - started_work\n  end\n\n  # EndDay is even simpler\n  struct EndDay <: ActorEvent{IndividualState}\n      actor_idx::Int\n  end\n\n  actor_precondition(evt::EndDay, physical) =\n      physical.actors[evt.actor_idx].state == working\n\n  get_rate_distribution(evt::EndDay, physical) =\n      physical.params[evt.actor_idx].done_dist\n\n  function fire!(evt::EndDay, physical, when, rng)\n      physical.actors[evt.actor_idx].state = ready\n      started_work = physical.actors[evt.actor_idx].started_working_time\n      physical.actors[evt.actor_idx].work_age += when - started_work\n  end\n\n  # Repair\n  struct Repair <: ActorEvent{IndividualState}\n      actor_idx::Int\n  end\n\n  actor_precondition(evt::Repair, physical) =\n      physical.actors[evt.actor_idx].state == broken\n\n  get_rate_distribution(evt::Repair, physical) =\n      physical.params[evt.actor_idx].repair_dist\n\n  function fire!(evt::Repair, physical, when, rng)\n      physical.actors[evt.actor_idx].state = ready\n      physical.actors[evt.actor_idx].work_age = 0.0\n  end","category":"page"},{"location":"plan/#Event-generation-in-particular","page":"Plan","title":"Event generation in particular","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"This is a macro language to generate events. This one would create a function called generators(::Type{MoveTransition}) that contains a list of EventGenerator objects.","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"@conditionsfor MoveTransition begin\n    @reactto changed(agent[i].loc) begin physical\n        agent_loc = physical.agent[i].loc\n        for direction in valid_directions(physical.geom, agent_loc)\n            generate(MoveTransition(agent_who, direction))\n        end\n    end\n    @reactto fired(InfectTransition(sick, healthy)) begin physical\n        for neigh in neighborsof(physical, healthy)\n            for nextneigh in neighborsof(physical, neigh)\n            generate(InfectTransition(neigh, nextneigh))\n        end\n    end\nend","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"The @reactto changed(agent[i].loc) creates a generator that reacts ToPlace where the search string is [:agent, ℤ, :loc]. Then it makes a function closure with the arguments (generate::Function, physical, i) where the value passed to i is the ℤ match.","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"The @reactto fired(InfectTransition(sick, healthy)) creates a generator that reacts ToEvent where the search string is [:InfectTransition] and the function closure has the arguments (generate::Function, physical, sick, healthy). The values for sick and healthy are taken from the matched event.","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"","category":"page"},{"location":"categorize/#Category-of-Simulation","page":"Category of Simulation","title":"Category of Simulation","text":"","category":"section"},{"location":"categorize/#Introduction","page":"Category of Simulation","title":"Introduction","text":"","category":"section"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"The ChronoSim.jl simulation framework doesn't fit exactly into some of the major categories of simulation. For those who want to understand ChronoSim.jl in relation to other simulation styles, and for those who think about how we express simulations, this section places ChronoSim.jl in the context of known simulation styles.","category":"page"},{"location":"categorize/#Exact,-Stochastic,-Continuous-time","page":"Category of Simulation","title":"Exact, Stochastic, Continuous-time","text":"","category":"section"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"The sampling algorithms used are exact, continuous-time sampling. Wikipedia calls these algorithms Gillespie Algorithms, but I would argue that is a misnomer because a simple heap-based first-to-fire style of sampling is an exact sampling of one of these systems, and this method was known well before Gillespie. It was known before Doob's algorithm, which was also before Gillespie.","category":"page"},{"location":"categorize/#The-Generalized-Semi-Markov-Process","page":"Category of Simulation","title":"The Generalized Semi-Markov Process","text":"","category":"section"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"Simulations in ChronoSim.jl define a stochastic process. The closest analog to that stochastic process is a Generalized Semi-Markov Process (GSMP). A GSMP defines a set of states, p_i, indexed by i. It defines a set of stochastic processes where each stochastic process depends on a subset of the p_i. We would now call these individual counting processes. In the GSMP, each counting process proceeds according to a clock rate, which is the hazard rate of a distribution.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"Each event in an GSMP changes a subset of the state. If you zoom out, you can ask how the whole state, all of the p_i, change when a single process fires. This defines a transition for the system as a whole. Zooming out like this shows the GSMP defines a semi-Markov process, which is a Markov process that doesn't limit the distribution of times between jumps to being Exponentially-distributed.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"The state of a GSMP is its physical states, the p_i, and the state of each clock, which is the time it has run down. ChronoSim borrows this name \"physical state.\"","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"The GSMP was a fantastic invention in its day. It used the crutch of the substates, p_i, to give the processes a way to be long-lived when other processes in the system fired. The dependency graph between substates and transitions became what Gibson and Bruck called a reaction graph in the Next Reaction method in 2000.","category":"page"},{"location":"categorize/#Using-Anderson-and-Kurtz-to-Pull-Out-Samplers","page":"Category of Simulation","title":"Using Anderson and Kurtz to Pull Out Samplers","text":"","category":"section"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"There is a book by Anderson and Kurtz, called <i>Stochastic Analysis of Biochemical Systems</i>, Springer 2015, that clarifies what defines a minimal continuous-time process and its sampler. In that book, they take all of the history of how to define the state of a continuous-time stochastic simulation and throw it out the window. All that's left is the sequence of events and times that record jumps in a set of counting processes. They call it a \"filtration\" in this probabilistic context.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"What was important for ChronoSim.jl is that Anderson and Kurtz showed that all of the sampling machinery can be pulled out of the simulation. Only the states and times of each counting process need to be known to the sampler. That's enough to make a complete, highly-optimized sampler in CompetingClocks.jl while pulling out into the ChronoSim framework the logic of what happens when an event fires.","category":"page"},{"location":"categorize/#Actuarial-Simulation-and-Reliability-Simulation","page":"Category of Simulation","title":"Actuarial Simulation and Reliability Simulation","text":"","category":"section"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"Both actuaries and reliability modelers pay close attention to whether simulations accurately reflect measured and estimated hazard rates of events. Both bodies of literature contain closed-form solutions for multi-state simulations with time-varying hazard rates. These fields focus less on engineering methods for simulation.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"ChronoSim.jl is an attempt to be the inverse of survival analysis. The goal of the care in defining events and distributions in time is to be faithful to how hazard rates depend on state. We're taking engineering approaches and bringing the statistical tools to the fore.","category":"page"},{"location":"categorize/#Generalized-Stochastic-Petri-Nets","page":"Category of Simulation","title":"Generalized Stochastic Petri Nets","text":"","category":"section"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"The Generalized Stochastic Petri Net (GSPN) was popular in the 1990's and more popular after 2000 when Gibson and Bruck's work (and the uncited work of Kurtz) contributed to the speed of sampling.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"A GSPN is a set of Places where a place can hold one or more Tokens. A token can be represent presence or absence at a place, or a token can be \"colored,\" which means it carries state. Think of it as a struct. The placement of tokens on places defines a Marking, and a Marking defines the physical state of the system. Transitions take tokens as input and produce tokens. They specify which tokens they consume and produce through a graph that connects transitions to places and an annotation on that graph indicating how many tokens are consumed or produced from each place.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"You can use a GSPN to define a chemical simulation. It doesn't take much work. You need to use a specific formula for how the rate of a reaction (transition) depends on the number of molecules (tokens) of each chemical species (place).","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"Theoreticians love GSPN because the whole graph of the simulation is laid bare. It's created and initialized before the simulation runs. It's a simple mathematical trick to calculate reachability of a future state from the current state. For instance, given the current state, it is possible for the system to arrive in a state that is a failure mode? It's great for safety guarantees.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"The big problem with GSPN is that they are burdensome to create. To quote Bryan Grenfell, \"We tried that back then and it was awful.\" If you create a model with individuals stratified by age, by sex, by location, and by disease state, you've created a combinatorially large simulation with lots of careful coding required.","category":"page"},{"location":"categorize/#Letting-go-of-some-rules","page":"Category of Simulation","title":"Letting go of some rules","text":"","category":"section"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"If we agree that we don't necessarily need to compute an exact reachability graph for a simulation, then we can let go of a lot of the pain of a GSPN.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"ChronoSim.jl builds a GSPN-style bipartite graph of places and events on the fly as it computes a simulation. It watches the precondition() functions to record what state a event depends on. It watches the enable() functions to record what events the rate of a event depends on. When a event fires, the list of changes to state are compared against the list of dependencies of all existing, currently-enabled events in order to update their enabling and rates. ChronoSim.jl tries to side-step the pain points of GSPN by making generation of dependencies dynamic.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"It also becomes easy to implement immediate events. These are events that fire at the same time as the timed event. If we think of the system as one semi-Markov process, the transition of that semi-Markov state is calculated from the timed event and all immediate events together.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"In a GSPN, the enabling of transitions depends only on the state. That's the only way to do it. If we instead take Anderson and Kurtz as our guide, it's clear that the events are the least, complete description of the history of the system. There is no reason not to include the ability to trigger the next event based on the previous event, so that is included in ChronoSim.jl as a possibility.","category":"page"},{"location":"categorize/#Agent-based","page":"Category of Simulation","title":"Agent-based","text":"","category":"section"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"From the perspective above, agent-based simulation can be done with any of the above methods. What makes a simulation agent-based is the imposition of the invariants on the system. For instance, if we make a rule that a rabbit is in a field, the invariant that makes the simulation agent-based would be that the rabbit doesn't disappear and reappear.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"Whether a simulation made with ChronoSim.jl is agent-based depends on what you define in the simulation. It's not intrinsic to the simulation framework. It's also not difficult to implement.","category":"page"},{"location":"categorize/#Formal-methods","page":"Category of Simulation","title":"Formal methods","text":"","category":"section"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"The way ChronoSim.jl defines events looks so much like TLA+ that it looks like a transliteration. It started from Anderson and Kurtz's probability theory, not from TLA+. The convergence is just a sign of similar good taste.","category":"page"},{"location":"categorize/#Conclusion","page":"Category of Simulation","title":"Conclusion","text":"","category":"section"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"ChronoSim.jl is","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"Exact, stochastic, continuous-time sampling.\nProcess-interaction models, maybe more properly called state-mediated.\nWith time-varying hazards and immediate transitions.\nGenerating transitions dynamically.","category":"page"},{"location":"categorize/","page":"Category of Simulation","title":"Category of Simulation","text":"","category":"page"},{"location":"not_chrono/#Starting-from-Simple-Simulation","page":"Why Not Hand Made","title":"Starting from Simple Simulation","text":"","category":"section"},{"location":"not_chrono/#Hand-made-Can-Be-Excellent","page":"Why Not Hand Made","title":"Hand-made Can Be Excellent","text":"","category":"section"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"Let's make a cute little simulation of wandering, spawing agents without using ChronoSim.jl. This is less thorough than the spatial rock-paper-scissors in Agents.jl. Start with a state that will be a vector of Agents.","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"using DataStructures, Distributions, Random\nrng = Xoshiro(92347223)\n@enum Matter Rock Paper Scissors\nWINNER = Dict(\n    (Rock, Rock) => 2,\n    (Paper, Paper) => 2,\n    (Scissors, Scissors) => 2,\n    (Rock, Paper) => 2,\n    (Rock, Scissors) => 1,\n    (Paper, Rock) => 1,\n    (Paper, Scissors) => 2,\n    (Scissors, Rock) => 2,\n    (Scissors, Paper) => 1,\n)\nmutable struct Agent\n    location::Vector{Int64}\n    kind::Matter\nend;\nnothing #hide","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"We need a queue of events that happen next.","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"μ, γ = (1.0, 3.0)  # Rates for movement and spawning.\nqueue = BinaryMinHeap{Tuple{Float64,Tuple}}()\nschedule(queue, distribution, key) = push!(queue, (rand(rng, distribution), key));\nnothing #hide","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"The heart of the simulation will process the event to fire and then add future events to the queue.","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"DIRECTIONS = [[-1, 0], [1, 0], [0, 1], [0, -1]]\nevent_dict = Dict(\n    :move => function (state, when, who, direction)\n        newloc = state.agent[who].location + DIRECTIONS[direction]\n        if checkbounds(Bool, state.locations[newloc])\n            if state.locations[newloc] == 0\n                state.locations[newloc] = who\n                state.locations[state.agent[who].location] = 0\n            else\n                opponent = state.locations[newloc]\n                if WINNER[(state.agent[who].kind, state.agent[opponent].kind)] == 1\n                    state.locations[newloc] = who\n                    state.locations[state.agent[who].location] = 0\n                    state.agent[opponent].location = [0, 0]\n                end\n            end\n        end\n        schedule(queue, Exponential(μ), (:move, who, rand(rng, 1:length(DIRECTIONS))))\n    end,\n    :spawn => function (state, when, who)\n        kind = state.agent[who].kind\n        push!(state.agent, Agent(state.agent[who].location, kind))\n        child = length(state.agent)\n        schedule(queue, Exponential(μ), (:move, child, rand(rng, 1:length(DIRECTIONS))))\n        schedule(queue, Exponential(γ), (:spawn, child))\n        schedule(queue, Exponential(γ), (:spawn, who))\n    end,\n);\nnothing #hide","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"The main loop of the simulation ends up being initialization and a small event loop.","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"mutable struct Board\n    agent::Vector{Agent}\n    locations::Array{Int,2}\n    Board(n) = new(Agent[], zeros(Int, n, n))\nend","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"function rununtil(eventcnt)     N = 10     state = Board(N)     for aidx in 1:N         locfound = false         agentloc = [0, 0]         while !locfound             agentloc = rand(rng, 1:N, 2)             locfound = state.locations[agentloc[1], agentloc[2]] == 0         end         agent = Agent(agentloc, rand(rng, instances(Matter)))         state.locations[agentloc[1], agentloc[2]] = aidx         push!(state.agent, agent)         schedule(queue, Exponential(μ), (:move, aidx, rand(rng, 1:length(DIRECTIONS))))         schedule(queue, Exponential(γ), (:spawn, aidx))     end     now = 0.0     for eventidx in 1:eventcnt         (when, (eventtype, args...)) = pop!(queue)         now = when         @show (when, eventtype, args)         # Skip events if they refer to an agent that has been knocked off the board.         if state.agent[args[1]].location[1] != 0             eventdict[eventtype](state, now, args...)         end     end end run_until(10)","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"This works great because it's very clear how events flow, which makes debugging easy. Why make life any more complicated?","category":"page"},{"location":"not_chrono/#Why-change","page":"Why Not Hand Made","title":"Why change","text":"","category":"section"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"There is a moment in the event logic where it decides what events could happen next. Let's say multiple events could queue up the same kind of follow-up event. Shouldn't the follow-up event decide when it could happen instead of the events that queue it? And if an event is no longer possible, shouldn't there be a way to cancel it?","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"tip: Idea\nLet's put the precondition for an event to fire with the event itself.","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"What if we want to extend the simulation with more events? You need to go in and change what events are queued after one has fired.","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"tip: Idea\nLet's use an Observer pattern to let an event subscribe to previous events or to state changes.","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"There is another complication that is sometimes overlooked for continuous-time simulation. When the state of a simulation changes, an event that was already queued might need to happen sooner or it might be pushed back in time. This is a re-enabling of the event where it can re-evaluate its probability to fire at future times.","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"tip: Idea\nLet's explicitly calculate a re-enabling time when appropriate.","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"Let's see what ChronoSim does with a similar simulation.","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"using ChronoSim\nusing ChronoSim.ObservedState\nimport ChronoSim: precondition, enable, fire!, generators\n\n@keyedby Critter Int64 begin\n    location::Vector{Int}\n    kind::Matter\nend\n\n@keyedby Square Tuple{Int64,Int64} begin\n    resident::Int64\nend\n\n@observedphysical Land begin\n    agent::ObservedVector{Critter}\n    board::ObservedArray{Square,2}\nend\n\nfunction Land(board_side::Int, person_cnt::Int)\n    for aidx in 1:N\n        loc_found = false\n        agent_loc = [0, 0]\n        while !loc_found\n            agent_loc = rand(rng, 1:N, 2)\n            loc_found = state.locations[agent_loc[1], agent_loc[2]] == 0\n        end\n        agent = Agent(agent_loc, rand(rng, instances(Matter)))\n        state.locations[agent_loc[1], agent_loc[2]] = aidx\n        push!(state.agent, agent)\n        schedule(queue, Exponential(μ), (:move, aidx, rand(rng, 1:length(DIRECTIONS))))\n        schedule(queue, Exponential(γ), (:spawn, aidx))\n    end\nend","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"This page was generated using Literate.jl.","category":"page"},{"location":"not_chrono/","page":"Why Not Hand Made","title":"Why Not Hand Made","text":"","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#ChronoSim.DepNetNaive","page":"Reference","title":"ChronoSim.DepNetNaive","text":"For testing, we make an equivalent version of the dependency network but this one uses a very different internal structure, an edge list.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ChronoSim.DependencyNetwork","page":"Reference","title":"ChronoSim.DependencyNetwork","text":"This is a multi-graph from places to events. It is a multi-graph because there can be two kinds of edges from the same place to the same event: an enabling edge and a rate edge. The graph is mutable, too, so you can add and remove events which adds and removes edges from the graph.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ChronoSim.EventGenerator","page":"Reference","title":"ChronoSim.EventGenerator","text":"EventGenerator(match_what, matchstr, generator::Function)\n\nWhen an event fires, it changes the physical state. The simulation observes which parts of the physical state changed and sends those parts to this EventGenerator. The EventGenerator is a rule that matches changes to the physical state and creates SimEvent that act on that physical state.\n\nThe matchstr is a list of symbols (array_name, ℤ, struct_member). The ℤ represents the integer index within the array. For instance, if we simulated chess, it might be (:board, ℤ, :piece).\n\nThe generator is a callback that the simulation uses to determine which events need to be enabled given recent changes to the state of the board. Its signature is:\n\n    callback_function(f::Function, physical_state, indices...)\n\nHere the indices are the integer index that matches the ℤ above. This callback function should look at the physical state and call f(transition) where transition is an instance of SimEvent.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ChronoSim.InitializeEvent","page":"Reference","title":"ChronoSim.InitializeEvent","text":"InitializeEvent is a concrete transition type that represents the first event in the system, initialization.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ChronoSim.Member","page":"Reference","title":"ChronoSim.Member","text":"This represents a field in a struct. It is a wrapper around Symbol. We wrap the Symbol so that it doesn't conflict with dictionary keys that are symbols.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ChronoSim.PhysicalState","page":"Reference","title":"ChronoSim.PhysicalState","text":"PhysicalState is an abstract type from which to inherit the state of a simulation. A PhysicalState should put all mutable values, the values upon which events depend, into TrackedVector objects. For instance:\n\n@tracked_struct Square begin\n    occupant::Int\n    resistance::Float64\nend\n\n# Everything we know about an agent.\n@tracked_struct Agent begin\n    health::Health\n    loc::CartesianIndex{2}\nend\n\nmutable struct BoardState <: PhysicalState\n    board::TrackedVector{Square}\n    agent::TrackedVector{Agent}\nend\n\nThe PhysicalState may contain other properties, but those defined with TrackedVectors are used to compute the next event in the simulation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ChronoSim.SimEvent","page":"Reference","title":"ChronoSim.SimEvent","text":"SimEvent\n\nThis abstract type is the parent of all transitions in the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ChronoSim.SimulationFSM-Tuple{Any, Any}","page":"Reference","title":"ChronoSim.SimulationFSM","text":"SimulationFSM(physical_state, trans_rules; seed, rng, sampler, observer=nothing)\n\nCreate a simulation.\n\nThe physical_state is of type PhysicalState. The sampler is of type CompetingClocks.SSA. The trans_rules are a list of type SimEvent. The seed is an integer seed for a Xoshiro random number generator. The observer is a callback with the signature:\n\nobserver(physical, when::Float64, event::SimEvent, changed_places::AbstractSet{Tuple})\n\nThe changed_places argument is a set-like object with tuples that are keys that represent which places were changed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.access_to_argnames-Tuple{Expr}","page":"Reference","title":"ChronoSim.access_to_argnames","text":"access_to_argnames(expr)\n\nIt extracts variable arguments to an accessor expression. An accessor expression uses getfield or getindex to find members of structs and containers. Turns this: :(agent[j].value[k]), into this: [:(j), :(k)].\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.access_to_searchkey-Tuple{Expr}","page":"Reference","title":"ChronoSim.access_to_searchkey","text":"access_to_searchkey(expr::Expr)\n\nConvert a Julia access expression into a search key pattern for the event generator system. Field names become Member objects, and array/container indices become MEMBERINDEX placeholders.\n\nExamples\n\n# Simple member access\njulia> access_to_searchkey(:(obj.field))\n[Member(:obj), Member(:field)]\n\n# Array access with index\njulia> access_to_searchkey(:(arr[5].field))  \n[Member(:arr), MEMBERINDEX, Member(:field)]\n\n# Multi-dimensional array access\njulia> access_to_searchkey(:(board[i][j].piece))\n[Member(:board), MEMBERINDEX, MEMBERINDEX, Member(:piece)]\n\nThe resulting pattern is used to match against place keys in the simulation's state change tracking.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.capture_state_changes-Tuple{Function, Any}","page":"Reference","title":"ChronoSim.capture_state_changes","text":"capture_state_changes(f::Function, physical_state)\n\nThe callback function f will modify the physical state. This function records which parts of the state were modified. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.capture_state_reads-Tuple{Function, Any}","page":"Reference","title":"ChronoSim.capture_state_reads","text":"capture_state_reads(f::Function, physical_state)\n\nThe callback function f will read the physical state. This function records which parts of the state were read. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.clock_key-Tuple{T} where T<:SimEvent","page":"Reference","title":"ChronoSim.clock_key","text":"clock_key(::SimEvent)::Tuple\n\nAll SimEvent objects are immutable structs that represent events but don't carry any mutable state. A clock key is a tuple version of an event.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.common_base_key_tuple-Tuple{Any}","page":"Reference","title":"ChronoSim.common_base_key_tuple","text":"Look at events and determine a common base type. Internally the simulation tracks events with sets of tuples by turning each event instance into a tuple. If all the tuples have the same type, this should turn out to be performant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.deal_with_changes-Union{Tuple{CK}, Tuple{Sampler}, Tuple{State}, Tuple{SimulationFSM{State, Sampler, CK}, Any, Any}} where {State, Sampler, CK}","page":"Reference","title":"ChronoSim.deal_with_changes","text":"deal_with_changes(sim::SimulationFSM)\n\nAn event changed the state. This function modifies events to respond to changes in state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.escaped_args-Tuple{Any}","page":"Reference","title":"ChronoSim.escaped_args","text":"Instead of escaping the argument list as-is, we reach into arguments that are tuples and escape them individually. The idea is to destructure the arguments into escaped variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.fire!-Tuple{SimulationFSM, Any, Any}","page":"Reference","title":"ChronoSim.fire!","text":"fire!(sim::SimulationFSM, time, event_key)\n\nLet the event act on the state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.generators-Tuple{Type{<:SimEvent}}","page":"Reference","title":"ChronoSim.generators","text":"generators(::Type{SimEvent})::Vector{EventGenerator}\n\nEvery transition in the simulation needs generators that notice changes to state or events fired and create the appropriate transitions. Implement a generators function as part of the interface of each transition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.initialize!-Tuple{Any, Function, SimulationFSM}","page":"Reference","title":"ChronoSim.initialize!","text":"Initialize the simulation. You could call it as a do-function. It is structured this way so that the simulation will record changes to the physical state.\n\n    initialize!(sim) do init_physical\n        initialize!(init_physical, agent_cnt, sim.rng)\n    end\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.isconsistent-Tuple{PhysicalState}","page":"Reference","title":"ChronoSim.isconsistent","text":"isconsistent(physical_state)\n\nA simulation in debug mode will assert isconsistent(physical_state) is true. Override this to verify the physical state of your simulation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.isimmediate-Tuple{Type{<:SimEvent}}","page":"Reference","title":"ChronoSim.isimmediate","text":"isimmediate(EventType)\n\nAn immediate event should return true for this function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.key_clock-Tuple{Tuple, Dict{Symbol, DataType}}","page":"Reference","title":"ChronoSim.key_clock","text":"key_clock(key::Tuple, event_dict::Dict{Symbol, DataType})::SimEvent\n\nTakes a tuple of the form (:symbol, arg, arg) and a dictionary mapping symbols to struct types, and returns an instantiation of the struct named by :symbol. We pass in the list of datatypes because, if we didn't, then instantiation of a type from a symbol would need to search for the correct constructor in the correct module, and that would be both wrong and slow.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.over_generated_events-Tuple{Function, Vararg{Any, 4}}","page":"Reference","title":"ChronoSim.over_generated_events","text":"over_generated_events(f::Function, generators, physical, fired_event_key, changed_places)\n\nGiven a fired event and the set of places changed by that event, create new events that may depend on that fired event and those changed places.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.over_tracked_physical_state-Union{Tuple{T}, Tuple{Function, T}} where T<:PhysicalState","page":"Reference","title":"ChronoSim.over_tracked_physical_state","text":"over_tracked_physical_state(fcallback::Function, physical::PhysicalState)\n\nIterate over all tracked vectors in the physical state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.run-Tuple{SimulationFSM, SimEvent, Function, Function}","page":"Reference","title":"ChronoSim.run","text":"run(simulation, initializer, stop_condition)\n\nGiven a simulation, this initializes the physical state and generates a trajectory from the simulation until the stop condition is met. The initializer is either a function whose argument is a physical state and returns nothing, or it is an event key for an event that initializes the system. The stop condition is a function with the signature:\n\nstop_condition(physical_state, step_idx, event::SimEvent, when)::Bool\n\nThe event and when passed into the stop condition are the event and time that are about to fire but have not yet fired. This lets you enforce a stopping time that is between events.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.trace_likelihood-Tuple{SimulationFSM, SimEvent, Function, Any}","page":"Reference","title":"ChronoSim.trace_likelihood","text":"The trace is a Vector{Tuple{Float64,SimEvent}}. That is, it's a list of tuples containing (when, what event). In order to calculate log-likelihood of a simulation, pass it a sampler that tracks log-likelihood. For instance,\n\nbase_sampler = CombinedNextReaction{K,T}()\nmemory_sampler = MemorySampler(base_sampler)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.@conditionsfor-Tuple{Any, Any}","page":"Reference","title":"ChronoSim.@conditionsfor","text":"@conditionsfor EventType begin\n    @reactto ... end\n    @reactto ... end\nend\n\nGenerates a generators(::Type{EventType}) function containing all the EventGenerators defined in the @reactto blocks.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#ChronoSim.@reactto-Tuple{Any}","page":"Reference","title":"ChronoSim.@reactto","text":"@reactto changed(array[index].field) do physical\n    # generator body\nend\n\n@reactto fired(EventType(args...)) do physical\n    # generator body\nend\n\nCreates an EventGenerator that reacts to state changes or event firings. Used within @conditionsfor blocks.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#ChronoSim.ObservedState.access_to_placekey-Tuple{Expr}","page":"Reference","title":"ChronoSim.ObservedState.access_to_placekey","text":"access_to_placekey(expr)\n\nThis function takes an expression for member access to a hierarchical container and converts it into a place key. For instance:\n\nAccessor expression Place key\nstate.agent[j].armor (:agent, j, :armor)\nsim.board[i, j].fval (:board, (i, j), :fval)\nstate.param (:param,)\nsim.adict[(name, kind)] (:adict, (name, kind))\nphysical.land[square].grass (:land, square, :grass)\n\nThe output is also an Expr-type object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.capture_state_changes-Tuple{Function, ChronoSim.ObservedState.ObservedPhysical}","page":"Reference","title":"ChronoSim.capture_state_changes","text":"capture_state_changes(f::Function, physical_state)\n\nThe callback function f will modify the physical state. This function records which parts of the state were modified. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.capture_state_reads-Tuple{Function, ChronoSim.ObservedState.ObservedPhysical}","page":"Reference","title":"ChronoSim.capture_state_reads","text":"capture_state_reads(f::Function, physical_state)\n\nThe callback function f will read the physical state. This function records which parts of the state were read. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.ObservedState.@keyedby-Tuple{Any, Any, Any}","page":"Reference","title":"ChronoSim.ObservedState.@keyedby","text":"@keyedby StructName IndexType begin\n    field1::Type1\n    field2::Type2\n    ...\nend\n\nCreate a mutable struct with the given fields plus automatic _container::Any and _index::IndexType fields. The generated constructor only requires the user-defined fields.\n\nExample\n\n@keyedby MyElement Int64 begin\n    val::Int64\n    name::String\nend\n\nThis generates a struct equivalent to:\n\nmutable struct MyElement\n    val::Int64\n    name::String\n    _container::Any\n    _index::Int64\n    MyElement(val, name) = new(val, name)\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/#ChronoSim.ObservedState.@observe-Tuple{Any}","page":"Reference","title":"ChronoSim.ObservedState.@observe","text":"@observe expr\n\nTrack reads and writes to ObservedPhysical state. For reads, records the access in obsread and returns the value. For writes, records the access in obsmodified and performs the assignment.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#ChronoSim.ObservedState.@observedphysical-Tuple{Any, Any}","page":"Reference","title":"ChronoSim.ObservedState.@observedphysical","text":"@observedphysical <typename> <definition block>\n\nThis macro defines a physical state that uses the ObservedState machinery to track changes to that physical state.\n\nFor example:\n\n@keyedby Int Piece begin\n    speed::Float64\n    kind::String\nend\n\n@keyedby NTuple{2,Int64} Square begin\n    grass::Float64\n    food::Float64\nend\n\n@observedphysical Board begin\n    board::ObservedArray{Square,2}\n    actor::ObservedDict{Int,Piece}\n    params::Dict{Symbol,Float64}\n    actors_max::Int64\nend\n\nThis macro creates a struct that contains tracking information about its Observed members, so in the example params would not be tracked. The Board type has a parent type ObservedPhysical which has the parent type ChronoSim.PhysicalState.\n\nExpanding the macro, we would see:\n\nmutable struct Board <: ObservedPhysical\n    board::ObservedArray{Square,2}\n    actor::ObservedDict{Int,Piece}\n    params::Dict{Symbol,Float64}\n    actors_max::Int64\n    obs_modified::Vector{Tuple}\n    obs_read::Vector{Tuple}\n    Board(board, actor, params, actors_max) = ...\nend\n\nHere, the list of read and modified state uses the abstract type Tuple because it unifies the way changed state is reported for the two observed containers: (:board, (2,2), :grass) and (:actor, 7, :speed). The ellipsis above for the constructor is a constructor that initializes obs_modified and obs_read to empty vectors.\n\n\n\n\n\n","category":"macro"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"whatitis/#What-This-Simulation-Framework-Does","page":"What It Does","title":"What This Simulation Framework Does","text":"","category":"section"},{"location":"whatitis/#High-level-of-what-defines-an-event","page":"What It Does","title":"High-level of what defines an event","text":"","category":"section"},{"location":"whatitis/","page":"What It Does","title":"What It Does","text":"This is a continuous-time simulation, which means only one event happens at a time. This simulation framework structures the firing of an event so that each event maintains responsibility for its own correct behavior given the state of the system.","category":"page"},{"location":"whatitis/","page":"What It Does","title":"What It Does","text":"The next event is chosen by a Sampler. That event contains a type and a tuple of event-specific identifiers.\nThe fire!() function for that event is called. This fire!() function modifies the state.\nAll events register to react to specific previous events or specific changes to the state of the system. It's an observer pattern where each field within the state gets its own key. Each event registered to respond to the actions of the fire!() function will be called.\nFor each of those events, it runs its precondition() function to see whether it really should be enabled. If so,\nAll enabled events decide, given the current state and time, the distribution of future times at which they could fire!().\nThe system returns to the top of the loop.","category":"page"},{"location":"whatitis/","page":"What It Does","title":"What It Does","text":"As a result, for each event we define:","category":"page"},{"location":"whatitis/","page":"What It Does","title":"What It Does","text":"An immutable struct type that functions as an Event Key.\nA @conditionsfor macro that says which events and states this event reacts to.\nA precondition() function that returns true if this event could fire.\nAn enable() function that returns a distribution of times.\nAn optional reenable() function for events that change their rates if the state changes.\nA fire!() function where the event changes the state.","category":"page"},{"location":"whatitis/#Components-in-the-ChronoSim-framework","page":"What It Does","title":"Components in the ChronoSim framework","text":"","category":"section"},{"location":"whatitis/","page":"What It Does","title":"What It Does","text":"There are four main components of the ChronoSim framework that make simulations possible.","category":"page"},{"location":"whatitis/","page":"What It Does","title":"What It Does","text":"ObservedState gives you a way to define a struct containing vectors or dictionaries of structs so that any read from or write to that struct can be observed with a subject-observer kind of pattern.\nEventGenerator is a small macro language to make it easier to observe changes to the state or previous events and generate candidate events that might be enableable.\nCompetingClocks.jl handles sampling which event is next, optimizing this process for different types of distributions. This also provides the ability to compute likelihoods so that you can do Markov Chain Monte Carlo with a simulation.\nThe main ChronoSim SimulationFSM is a finite-state machine for firing an event, applying immediate events, tracking state changes, updating reenabled events, disabling events whose precondition no longer is true, and enabling new events.","category":"page"},{"location":"whatitis/","page":"What It Does","title":"What It Does","text":"","category":"page"},{"location":"event_update/#How-Event-States-are-Updated","page":"Event Updates","title":"How Event States are Updated","text":"","category":"section"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The main loop of the framework for simulation will fire an event, look at changed places, and then update the events in the system. This turns out to be complicated, so let's discuss it here.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"An event has","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A key which identifies its relationship to physical state.\nA set of places upon which its precondition depends.\nA set of places upon which its rate depends.\nA rate (distribution in time) that is set in the Sampler by the enable() function.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The same event key, when applied to a different physical state, may depend on different sets of places. This is not true for a traditional GSPN or GSMP, but it's how we think about events. For instance, a Move(agentidx, rightdirection) will depend on space to the right of the agent, but which space must be empty changes as the agent moves.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A simulation has:","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A set of enabled events.\nThe event that just fired.\nA set of states that were modified when the event fired.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The goal of the main loop of the simulation, once it has fired the event is to modify:","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The set of enabled events, by disabling those with failed preconditions or enabling those generated.\nThe set of places upon which precondition or rates depends for affected events.\nThe rate of events for which their place dependencies changed in value or for which the set of places has changed.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"Before and after this update, what can the states of an event be?","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"Disabled -> enabled and enabled -> disabled.\nSets of places can change.\nMaybe just the rate is called again.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The notion of re-enabling is a little tough. I will define that any time an event with the same clock key is enabled before and after firing, and the rate-depending places have changed, it is re-enabled. That's a firm definition. Rate-depending places can be a different set of places or they can have been written to. Either way.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"What sets of events do we have?","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The set of all events that depend on ANY changed places.\nThe set of those events whose preconditions still hold.\nThe set of those whose preconditions hold but they depend on different places.\nThe set of those whose rates depend on ANY changed places.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"Let's process the data this way, not an event at a time but a set of events at a time.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A question: When rules generate new events, they don't need to create existing events. If we just discovered an event is disabled, that too can be excluded. My question is whether the set of all generated events intersected with the set of enabled events is contained in the set of affected events.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"(generated events) ∩ (enabled events) ⊆ (affected event preconditions)","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The practical answer is that there aren't restrictions on event generation. The generator functions could generate lots of extra events, so there is no guarantee that those related to the recent modified places are all we will see.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"","category":"page"},{"location":"getting_started/#Getting-Started-with-ChronoSim.jl","page":"Getting Started","title":"Getting Started with ChronoSim.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is an example of using Literate.jl to create executable documentation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ChronoSim.jl is a simulation framework built on top of CompetingClocks.jl for event-driven simulations with dependency tracking.","category":"page"},{"location":"getting_started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First, let's import the package:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using ChronoSim","category":"page"},{"location":"getting_started/#Simple-Example","page":"Getting Started","title":"Simple Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here's how you would set up a basic simulation: (This is just an example structure - you'll replace this with actual working code)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"println(\"This is a placeholder example for Literate.jl integration\")","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"As you develop more examples, you can add them as .jl files in the literate_src/ directory. They will be automatically converted to markdown and included in the documentation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"simulation_state/#Simulation-State","page":"Simulation State","title":"Simulation State","text":"","category":"section"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"A simulation changes state over time. This kind of simulation enables and disables events depending on changes to the state, so you have to define a simulation state that can record that it was changed or read.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"The three sections below describe two ways to create a state that records its accesses and one way you could define your own custom state.","category":"page"},{"location":"simulation_state/#Struct-of-Observed-Vectors-and-Arrays","page":"Simulation State","title":"Struct of Observed Vectors and Arrays","text":"","category":"section"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"The ChronoSim.ObservedState module supplies macros and containers that make a simulation state that is a mutable struct containing containers of mutable structs.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"using ChronoSim.ObservedState\n@keyedby Piece Int begin\n    speed::Float64\n    kind::String\nend\n\n@keyedby Square NTuple{2,Int64} begin\n    grass::Float64\n    food::Float64\nend\n\n@observedphysical Board begin\n    board::ObservedArray{Square,2}\n    actor::ObservedDict{Int,Piece}\n    params::Dict{Symbol,Float64}\n    actors_max::Int64\nend\n\nboard_data = ObservedArray{Square}(undef, 3, 3)\nfor i in 1:3, j in 1:3\n    board_data[i, j] = Square(0.5, 1.0)\nend\n\nactor_data = ObservedDict{Int,Piece}()\nactor_data[1] = Piece(2.5, \"walker\")\nactor_data[2] = Piece(3.0, \"runner\")\n\nparams = Dict(:gravity => 9.8, :friction => 0.1)\nboard_state = Board(board_data, actor_data, params, 10)","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"When the simulation changes the speed of a piece, it will look normal:","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"board_state.actor[1].speed = 2.0","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"That assignment will be recorded as a modification of (:actor, 1, :speed).","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"If the simulation changes params or actors_max, those are not contained in ObservedArray or ObservedDict so they aren't recorded.","category":"page"},{"location":"simulation_state/#@Observe-Macro","page":"Simulation State","title":"@Observe Macro","text":"","category":"section"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"If you want to construct a physical state that uses different containers or data types, you may want to try the @observe macro in ChronoSim.ObservedState.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"Again, create an @observedphysical state so that it has the ability to record changes and reads. But here, include any containers you would like.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"@observedphysical Fireflies begin\n    watersource::Matrix{Float64}\n    wind::Float64\n    cnt::Int64\nend","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"This time, however, because there are no ObservedArray or ObservedDict to help record reads or writes to the state, use a macro to notify the state every time a firing function writes or an enabling function reads.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"value = @observe fireflies.watersource[i, j]\n@observe fireflies.wind = 2.7","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"The first use of @observe will record a read of (:watersource, (i, j)). The second use of @observe will record a write of (:wind,).","category":"page"},{"location":"simulation_state/#Custom-State","page":"Simulation State","title":"Custom State","text":"","category":"section"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"The physical state of a simulation is an architectural component of a simulation. The simulation framework interacts with the physical state in just two ways, so it is fairly simple to define your own version of a physical state that works for this simulation framework.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"The two functions a physical state must support are capture_state_changes and capture_state_reads. Here are the implementations used by ChronoSim.ObservedPhysical. The first argument, f::Function, is a firing function or an enabling function that modifies state or reads state.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"function capture_state_changes(f::Function, physical::ObservedPhysical)\n    empty!(physical.obs_modified)\n    result = f()\n    # Use ordered set here so that list is deterministic.\n    changes = OrderedSet(physical.obs_modified)\n    return (; result, changes)\nend\n\nfunction capture_state_reads(f::Function, physical::ObservedPhysical)\n    empty!(physical.obs_read)\n    result = f()\n    reads = OrderedSet(physical.obs_read)\n    return (; result, reads)\nend","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"","category":"page"},{"location":"architecture_diagram/#ChronoSim.jl-Framework-Architecture","page":"Architecture","title":"ChronoSim.jl Framework Architecture","text":"","category":"section"},{"location":"architecture_diagram/#Core-Components-and-Data-Flow","page":"Architecture","title":"Core Components and Data Flow","text":"","category":"section"},{"location":"architecture_diagram/","page":"Architecture","title":"Architecture","text":"graph TD\n    subgraph Framework\n        TS[Tracked State]\n        EG[Event Generation]\n        TU[Transition Updates]\n        TJS[Trajectory Sampling]\n        \n        TU -->|fire!| TS\n        TS -->|changes| EG\n        EG -->|possible events| TU\n        TJS -->|next event| TU\n    end\n    \n    style TU fill:#f9f,stroke:#333,stroke-width:4px\n    style Framework fill:#f0f0f0,stroke:#333,stroke-width:2px","category":"page"},{"location":"architecture_diagram/#Component-Descriptions","page":"Architecture","title":"Component Descriptions","text":"","category":"section"},{"location":"architecture_diagram/","page":"Architecture","title":"Architecture","text":"Transition Updates: The central orchestrator that manages event firing and state transitions\nTracked State: Monitors and tracks all state changes in the physical system\nEvent Generation: Creates new possible events based on state changes\nTrajectory Sampling: Selects the next event to fire based on the stochastic process","category":"page"},{"location":"architecture_diagram/#Data-Flow","page":"Architecture","title":"Data Flow","text":"","category":"section"},{"location":"architecture_diagram/","page":"Architecture","title":"Architecture","text":"fire!: Transition Updates executes state changes through the Tracked State\nchanges: Tracked State reports what changed to Event Generation\npossible events: Event Generation provides new/updated events to Transition Updates\nnext event: Trajectory Sampling selects which event fires next from the available events","category":"page"},{"location":"architecture_diagram/","page":"Architecture","title":"Architecture","text":"","category":"page"},{"location":"#ChronoSim","page":"ChronoSim","title":"ChronoSim","text":"","category":"section"},{"location":"","page":"ChronoSim","title":"ChronoSim","text":"ChronoSim is a stochastic discrete event simulation framework that automatically tracks and manages complex interdependencies between events and state changes for high-performance scientific computing applications.","category":"page"},{"location":"","page":"ChronoSim","title":"ChronoSim","text":"Exact stochastic simulation algorithm (SSA) for time-varying hazard rates.\nRule-based event generation.\nFine-grained coupling between state and events makes it easier to combine interacting behaviors in the same simulation.\nScientific computing focus.","category":"page"},{"location":"","page":"ChronoSim","title":"ChronoSim","text":"","category":"page"}]
}
