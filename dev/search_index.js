var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-Started-with-ChronoSim.jl","page":"Getting Started","title":"Getting Started with ChronoSim.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is an example of using Literate.jl to create executable documentation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ChronoSim.jl is a simulation framework built on top of CompetingClocks.jl for event-driven simulations with dependency tracking.","category":"page"},{"location":"getting_started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First, let's import the package:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using ChronoSim","category":"page"},{"location":"getting_started/#Simple-Example","page":"Getting Started","title":"Simple Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here's how you would set up a basic simulation: (This is just an example structure - you'll replace this with actual working code)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"println(\"This is a placeholder example for Literate.jl integration\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is a placeholder example for Literate.jl integration\n","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"As you develop more examples, you can add them as .jl files in the literate_src/ directory. They will be automatically converted to markdown and included in the documentation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"simulation_state/#Simulation-State","page":"Simulation State","title":"Simulation State","text":"","category":"section"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"A simulation changes state over time. This kind of simulation enables and disables events depending on changes to the state, so you have to define a simulation state that can record that it was changed or read.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"The three sections below describe two ways to create a state that records its accesses and one way you could define your own custom state.","category":"page"},{"location":"simulation_state/#Struct-of-Observed-Vectors-and-Arrays","page":"Simulation State","title":"Struct of Observed Vectors and Arrays","text":"","category":"section"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"The ChronoSim.ObservedState module supplies macros and containers that make a simulation state that is a mutable struct containing containers of mutable structs.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"using ChronoSim.ObservedState\n@keyedby Piece Int begin\n    speed::Float64\n    kind::String\nend\n\n@keyedby Square NTuple{2,Int64} begin\n    grass::Float64\n    food::Float64\nend\n\n@observedphysical Board begin\n    board::ObservedArray{Square,2}\n    actor::ObservedDict{Int,Piece}\n    params::Dict{Symbol,Float64}\n    actors_max::Int64\nend\n\nboard_data = ObservedArray{Square}(undef, 3, 3)\nfor i in 1:3, j in 1:3\n    board_data[i, j] = Square(0.5, 1.0)\nend\n\nactor_data = ObservedDict{Int,Piece}()\nactor_data[1] = Piece(2.5, \"walker\")\nactor_data[2] = Piece(3.0, \"runner\")\n\nparams = Dict(:gravity => 9.8, :friction => 0.1)\nboard_state = Board(board_data, actor_data, params, 10)","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"When the simulation changes the speed of a piece, it will look normal:","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"board_state.actor[1].speed = 2.0","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"That assignment will be recorded as a modification of (:actor, 1, :speed).","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"If the simulation changes params or actors_max, those are note contained in ObservedArray or ObservedDict so they aren't recorded.","category":"page"},{"location":"simulation_state/#@Observe-Macro","page":"Simulation State","title":"@Observe Macro","text":"","category":"section"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"If you want to construct a physical state that uses different containers or data types, you may want to try the @observe macro in ChronoSim.ObservedState.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"Again, create an @observedphysical state so that it has the ability to record changes and reads. But here, include any containers you would like.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"@observedphysical Fireflies begin\n    watersource::Matrix{Float64}\n    wind::Float64\n    cnt::Int64\nend","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"This time, however, because there are no ObservedArray or ObservedDict to help record reads or writes to the state, use a macro to notify the state every time a firing function writes or an enabling function reads.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"value = @observe fireflies.watersource[i, j]\n@observe fireflies.wind = 2.7","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"The first use of @observe will record a read of (:watersource, (i, j)). The second use of @observe will record a write of (:wind,).","category":"page"},{"location":"simulation_state/#Custom-State","page":"Simulation State","title":"Custom State","text":"","category":"section"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"The physical state of a simulation is an architectural component of a simulation. The simulation framework interacts with the physical state in just two ways, so it is fairly simple to define your own version of a physical state that works for this simulation framework.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"The two functions a physical state must support are capture_state_changes and capture_state_reads. Here are the implementations used by ChronoSim.ObservedPhysical. The first argument, f::Function, is a firing function or an enabling function that modifies state or reads state.","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"function capture_state_changes(f::Function, physical::ObservedPhysical)\n    empty!(physical.obs_modified)\n    result = f()\n    # Use ordered set here so that list is deterministic.\n    changes = OrderedSet(physical.obs_modified)\n    return (; result, changes)\nend\n\nfunction capture_state_reads(f::Function, physical::ObservedPhysical)\n    empty!(physical.obs_read)\n    result = f()\n    reads = OrderedSet(physical.obs_read)\n    return (; result, reads)\nend","category":"page"},{"location":"simulation_state/","page":"Simulation State","title":"Simulation State","text":"","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#ChronoSim.PhysicalState","page":"Reference","title":"ChronoSim.PhysicalState","text":"PhysicalState is an abstract type from which to inherit the state of a simulation. A PhysicalState should put all mutable values, the values upon which events depend, into TrackedVector objects. For instance:\n\n@tracked_struct Square begin\n    occupant::Int\n    resistance::Float64\nend\n\n# Everything we know about an agent.\n@tracked_struct Agent begin\n    health::Health\n    loc::CartesianIndex{2}\nend\n\nmutable struct BoardState <: PhysicalState\n    board::TrackedVector{Square}\n    agent::TrackedVector{Agent}\nend\n\nThe PhysicalState may contain other properties, but those defined with TrackedVectors are used to compute the next event in the simulation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ChronoSim.capture_state_changes-Tuple{Function, Any}","page":"Reference","title":"ChronoSim.capture_state_changes","text":"capture_state_changes(f::Function, physical_state)\n\nThe callback function f will modify the physical state. This function records which parts of the state were modified. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.capture_state_reads-Tuple{Function, Any}","page":"Reference","title":"ChronoSim.capture_state_reads","text":"capture_state_reads(f::Function, physical_state)\n\nThe callback function f will read the physical state. This function records which parts of the state were read. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.isconsistent-Tuple{PhysicalState}","page":"Reference","title":"ChronoSim.isconsistent","text":"isconsistent(physical_state)\n\nA simulation in debug mode will assert isconsistent(physical_state) is true. Override this to verify the physical state of your simulation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.over_generated_events-Tuple{Function, Vararg{Any, 4}}","page":"Reference","title":"ChronoSim.over_generated_events","text":"over_generated_events(f::Function, generators, physical, fired_event_key, changed_places)\n\nGiven a fired event and the set of places changed by that event, create new events that may depend on that fired event and those changed places.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.over_tracked_physical_state-Union{Tuple{T}, Tuple{Function, T}} where T<:PhysicalState","page":"Reference","title":"ChronoSim.over_tracked_physical_state","text":"over_tracked_physical_state(fcallback::Function, physical::PhysicalState)\n\nIterate over all tracked vectors in the physical state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.ObservedState.capture_state_changes-Tuple{Function, ChronoSim.ObservedState.ObservedPhysical}","page":"Reference","title":"ChronoSim.ObservedState.capture_state_changes","text":"capture_state_changes(f::Function, physical_state)\n\nThe callback function f will modify the physical state. This function records which parts of the state were modified. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.ObservedState.capture_state_reads-Tuple{Function, ChronoSim.ObservedState.ObservedPhysical}","page":"Reference","title":"ChronoSim.ObservedState.capture_state_reads","text":"capture_state_reads(f::Function, physical_state)\n\nThe callback function f will read the physical state. This function records which parts of the state were read. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ChronoSim.ObservedState.@keyedby-Tuple{Any, Any, Any}","page":"Reference","title":"ChronoSim.ObservedState.@keyedby","text":"@keyedby StructName IndexType begin\n    field1::Type1\n    field2::Type2\n    ...\nend\n\nCreate a mutable struct with the given fields plus automatic _container::Any and _index::IndexType fields. The generated constructor only requires the user-defined fields.\n\nExample\n\n@keyedby MyElement Int64 begin\n    val::Int64\n    name::String\nend\n\nThis generates a struct equivalent to:\n\nmutable struct MyElement\n    val::Int64\n    name::String\n    _container::Any\n    _index::Int64\n    MyElement(val, name) = new(val, name)\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/#ChronoSim.ObservedState.@observe-Tuple{Any}","page":"Reference","title":"ChronoSim.ObservedState.@observe","text":"@observe expr\n\nTrack reads and writes to ObservedPhysical state. For reads, records the access in obsread and returns the value. For writes, records the access in obsmodified and performs the assignment.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#ChronoSim.ObservedState.@observedphysical-Tuple{Any, Any}","page":"Reference","title":"ChronoSim.ObservedState.@observedphysical","text":"@observedphysical <typename> <definition block>\n\nThis macro defines a physical state that uses the ObservedState machinery to track changes to that physical state.\n\nFor example:\n\n@keyedby Int Piece begin\n    speed::Float64\n    kind::String\nend\n\n@keyedby NTuple{2,Int64} Square begin\n    grass::Float64\n    food::Float64\nend\n\n@observedphysical Board begin\n    board::ObservedArray{Square,2}\n    actor::ObservedDict{Int,Piece}\n    params::Dict{Symbol,Float64}\n    actors_max::Int64\nend\n\nThis macro creates a struct that contains tracking information about its Observed members, so in the example params would not be tracked. The Board type has a parent type ObservedPhysical which has the parent type ChronoSim.PhysicalState.\n\nExpanding the macro, we would see:\n\nmutable struct Board <: ObservedPhysical\n    board::ObservedArray{Square,2}\n    actor::ObservedDict{Int,Piece}\n    params::Dict{Symbol,Float64}\n    actors_max::Int64\n    obs_modified::Vector{Tuple}\n    obs_read::Vector{Tuple}\n    Board(board, actor, params, actors_max) = ...\nend\n\nHere, the list of read and modified state uses the abstract type Tuple because it unifies the way changed state is reported for the two observed containers: (:board, (2,2), :grass) and (:actor, 7, :speed). The ellipsis above for the constructor is a constructor that initializes obs_modified and obs_read to empty vectors.\n\n\n\n\n\n","category":"macro"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"#ChronoSim","page":"Home","title":"ChronoSim","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ChronoSim is a discrete event simulation framework for continuous-time, exact stochastic simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
