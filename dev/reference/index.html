<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · ChronoSim.jl</title><meta name="title" content="Reference · ChronoSim.jl"/><meta property="og:title" content="Reference · ChronoSim.jl"/><meta property="twitter:title" content="Reference · ChronoSim.jl"/><meta name="description" content="Documentation for ChronoSim.jl."/><meta property="og:description" content="Documentation for ChronoSim.jl."/><meta property="twitter:description" content="Documentation for ChronoSim.jl."/><meta property="og:url" content="https://adolgert.github.io/ChronoSim.jl/reference/"/><meta property="twitter:url" content="https://adolgert.github.io/ChronoSim.jl/reference/"/><link rel="canonical" href="https://adolgert.github.io/ChronoSim.jl/reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ChronoSim.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">ChronoSim</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../not_chrono/">Why Not Hand Made</a></li><li><a class="tocitem" href="../whatitis/">What It Does</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Simulation State</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../observedphysical/">Struct of Observed Vectors and Arrays</a></li><li><a class="tocitem" href="../observedmacro/">The @observe Macro</a></li><li><a class="tocitem" href="../customstate/">Custom State</a></li></ul></li><li><a class="tocitem" href="../categorize/">Category of Simulation</a></li></ul></li><li class="is-active"><a class="tocitem" href>Reference</a></li><li><span class="tocitem">Development</span><ul><li><a class="tocitem" href="../plan/">Plan</a></li><li><a class="tocitem" href="../event_update/">Event Updates</a></li><li><a class="tocitem" href="../architecture_diagram/">Architecture</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/ChronoSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/ChronoSim.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#ChronoSim.DepNetNaive"><code>ChronoSim.DepNetNaive</code></a></li><li><a href="#ChronoSim.DependencyNetwork"><code>ChronoSim.DependencyNetwork</code></a></li><li><a href="#ChronoSim.EventDependency"><code>ChronoSim.EventDependency</code></a></li><li><a href="#ChronoSim.EventGenerator"><code>ChronoSim.EventGenerator</code></a></li><li><a href="#ChronoSim.InitializeEvent"><code>ChronoSim.InitializeEvent</code></a></li><li><a href="#ChronoSim.Member"><code>ChronoSim.Member</code></a></li><li><a href="#ChronoSim.ObservedState.Address"><code>ChronoSim.ObservedState.Address</code></a></li><li><a href="#ChronoSim.ObservedState.ObservedSet"><code>ChronoSim.ObservedState.ObservedSet</code></a></li><li><a href="#ChronoSim.PhysicalState"><code>ChronoSim.PhysicalState</code></a></li><li><a href="#ChronoSim.SimEvent"><code>ChronoSim.SimEvent</code></a></li><li><a href="#ChronoSim.SimulationFSM-Tuple{Any, Any}"><code>ChronoSim.SimulationFSM</code></a></li><li><a href="#Base.show-Tuple{IO, ChronoSim.ObservedState.Address}"><code>Base.show</code></a></li><li><a href="#ChronoSim.ObservedState.access_to_placekey-Tuple{Expr}"><code>ChronoSim.ObservedState.access_to_placekey</code></a></li><li><a href="#ChronoSim.ObservedState.notify_all-Tuple{Any}"><code>ChronoSim.ObservedState.notify_all</code></a></li><li><a href="#ChronoSim.access_to_argnames-Tuple{Expr}"><code>ChronoSim.access_to_argnames</code></a></li><li><a href="#ChronoSim.access_to_searchkey-Tuple{Expr}"><code>ChronoSim.access_to_searchkey</code></a></li><li><a href="#ChronoSim.capture_state_changes-Tuple{Function, Any}"><code>ChronoSim.capture_state_changes</code></a></li><li><a href="#ChronoSim.capture_state_changes-Tuple{Function, ChronoSim.ObservedState.ObservedPhysical}"><code>ChronoSim.capture_state_changes</code></a></li><li><a href="#ChronoSim.capture_state_reads-Tuple{Function, Any}"><code>ChronoSim.capture_state_reads</code></a></li><li><a href="#ChronoSim.capture_state_reads-Tuple{Function, ChronoSim.ObservedState.ObservedPhysical}"><code>ChronoSim.capture_state_reads</code></a></li><li><a href="#ChronoSim.clock_key-Tuple{T} where T&lt;:SimEvent"><code>ChronoSim.clock_key</code></a></li><li><a href="#ChronoSim.common_base_key_tuple-Tuple{Any}"><code>ChronoSim.common_base_key_tuple</code></a></li><li><a href="#ChronoSim.deal_with_changes-Union{Tuple{CK}, Tuple{Sampler}, Tuple{State}, Tuple{SimulationFSM{State, Sampler, CK}, Any, Any, Any}} where {State, Sampler, CK}"><code>ChronoSim.deal_with_changes</code></a></li><li><a href="#ChronoSim.enable-Tuple{SimEvent, Any, Any}"><code>ChronoSim.enable</code></a></li><li><a href="#ChronoSim.escaped_args-Tuple{Any}"><code>ChronoSim.escaped_args</code></a></li><li><a href="#ChronoSim.fire!-Tuple{SimEvent, Any, Any, Any}"><code>ChronoSim.fire!</code></a></li><li><a href="#ChronoSim.fire!-Tuple{SimulationFSM, Any, Any}"><code>ChronoSim.fire!</code></a></li><li><a href="#ChronoSim.generators-Tuple{Type{&lt;:SimEvent}}"><code>ChronoSim.generators</code></a></li><li><a href="#ChronoSim.initialize!-Tuple{Any, Function, SimulationFSM}"><code>ChronoSim.initialize!</code></a></li><li><a href="#ChronoSim.isconsistent-Tuple{PhysicalState}"><code>ChronoSim.isconsistent</code></a></li><li><a href="#ChronoSim.isimmediate-Tuple{Type{&lt;:SimEvent}}"><code>ChronoSim.isimmediate</code></a></li><li><a href="#ChronoSim.key_clock-Tuple{Tuple, Dict{Symbol, DataType}}"><code>ChronoSim.key_clock</code></a></li><li><a href="#ChronoSim.over_event_rates-Tuple{Function, ChronoSim.EventDependency, Any, Any, Any}"><code>ChronoSim.over_event_rates</code></a></li><li><a href="#ChronoSim.over_generated_events-Tuple{Function, GeneratorSearch, Any, Any, Any}"><code>ChronoSim.over_generated_events</code></a></li><li><a href="#ChronoSim.over_generated_events-Tuple{Function, Vararg{Any, 4}}"><code>ChronoSim.over_generated_events</code></a></li><li><a href="#ChronoSim.over_tracked_physical_state-Union{Tuple{T}, Tuple{Function, T}} where T&lt;:PhysicalState"><code>ChronoSim.over_tracked_physical_state</code></a></li><li><a href="#ChronoSim.precondition-Tuple{SimEvent, Any}"><code>ChronoSim.precondition</code></a></li><li><a href="#ChronoSim.reenable-Tuple{SimEvent, Any, Any, Any}"><code>ChronoSim.reenable</code></a></li><li><a href="#ChronoSim.run-Tuple{SimulationFSM, SimEvent, Function, Function}"><code>ChronoSim.run</code></a></li><li><a href="#ChronoSim.sim_event_precondition-Tuple{SimEvent, Any}"><code>ChronoSim.sim_event_precondition</code></a></li><li><a href="#ChronoSim.trace_likelihood-Tuple{SimulationFSM, SimEvent, Function, Any}"><code>ChronoSim.trace_likelihood</code></a></li><li><a href="#ChronoSim.@conditionsfor-Tuple{Any, Any}"><code>ChronoSim.@conditionsfor</code></a></li><li><a href="#ChronoSim.@reactto-Tuple{Any}"><code>ChronoSim.@reactto</code></a></li><li><a href="#ChronoSim.ObservedState.@keyedby-Tuple{Any, Any, Any}"><code>ChronoSim.ObservedState.@keyedby</code></a></li><li><a href="#ChronoSim.ObservedState.@observedphysical-Tuple{Any, Any}"><code>ChronoSim.ObservedState.@observedphysical</code></a></li><li><a href="#ChronoSim.ObservedState.@obsread-Tuple{Any}"><code>ChronoSim.ObservedState.@obsread</code></a></li><li><a href="#ChronoSim.ObservedState.@obswrite-Tuple{Any}"><code>ChronoSim.ObservedState.@obswrite</code></a></li></ul><article><details class="docstring" open="true"><summary id="ChronoSim.DepNetNaive"><a class="docstring-binding" href="#ChronoSim.DepNetNaive"><code>ChronoSim.DepNetNaive</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>For testing, we make an equivalent version of the dependency network but this one uses a very different internal structure, an edge list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/depnet.jl#L115-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.DependencyNetwork"><a class="docstring-binding" href="#ChronoSim.DependencyNetwork"><code>ChronoSim.DependencyNetwork</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>This is a multi-graph from places to events. It is a multi-graph because there can be two kinds of edges from the same place to the same event: an enabling edge and a rate edge. The graph is mutable, too, so you can add and remove events which adds and removes edges from the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/depnet.jl#L8-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.EventDependency"><a class="docstring-binding" href="#ChronoSim.EventDependency"><code>ChronoSim.EventDependency</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EventDependency{ClockKey}(event_generator)</code></pre><p>Represents the dependency graph between the set of events and the set of physical states. It uses clock keys to represent events and physical addresses to represent the physical state. This struct combines dynamic event generation with a static graph in order to present to the framework a unified version of the bipartite graph of events and physical state. It could be replaced by a static graph of events and physical states, such as is used in generalized stochastic Petri nets (GSPN).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/placetoevent.jl#L3-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.EventGenerator"><a class="docstring-binding" href="#ChronoSim.EventGenerator"><code>ChronoSim.EventGenerator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EventGenerator(match_what, matchstr, generator::Function)</code></pre><p>When an event fires, it changes the physical state. The simulation observes which parts of the physical state changed and sends those parts to this <code>EventGenerator</code>. The <code>EventGenerator</code> is a rule that matches changes to the physical state and creates <code>SimEvent</code> that act on that physical state.</p><p>The <code>matchstr</code> is a list of symbols <code>(array_name, ℤ, struct_member)</code>. The ℤ represents the integer index within the array. For instance, if we simulated chess, it might be <code>(:board, ℤ, :piece)</code>.</p><p>The generator is a callback that the simulation uses to determine which events need to be enabled given recent changes to the state of the board. Its signature is:</p><pre><code class="language-julia hljs">    callback_function(f::Function, physical_state, indices...)</code></pre><p>Here the indices are the integer index that matches the ℤ above. This callback function should look at the physical state and call <code>f(transition)</code> where <code>transition</code> is an instance of <code>SimEvent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/generators.jl#L24-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.InitializeEvent"><a class="docstring-binding" href="#ChronoSim.InitializeEvent"><code>ChronoSim.InitializeEvent</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>InitializeEvent is a concrete transition type that represents the first event in the system, initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/events.jl#L75-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.Member"><a class="docstring-binding" href="#ChronoSim.Member"><code>ChronoSim.Member</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>This represents a field in a struct. It is a wrapper around Symbol. Wrap the Symbol so that it doesn&#39;t conflict with dictionary keys that are symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/physical_interface.jl#L70-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.PhysicalState"><a class="docstring-binding" href="#ChronoSim.PhysicalState"><code>ChronoSim.PhysicalState</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><code>PhysicalState</code> is an abstract type from which to inherit the state of a simulation. A <code>PhysicalState</code> should put all mutable values, the values upon which events depend, into <code>TrackedVector</code> objects. For instance:</p><pre><code class="language-julia hljs">@tracked_struct Square begin
    occupant::Int
    resistance::Float64
end

# Everything we know about an agent.
@tracked_struct Agent begin
    health::Health
    loc::CartesianIndex{2}
end

mutable struct BoardState &lt;: PhysicalState
    board::TrackedVector{Square}
    agent::TrackedVector{Agent}
end</code></pre><p>The <code>PhysicalState</code> may contain other properties, but those defined with <code>TrackedVectors</code> are used to compute the next event in the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/physical_interface.jl#L5-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.SimEvent"><a class="docstring-binding" href="#ChronoSim.SimEvent"><code>ChronoSim.SimEvent</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>SimEvent</p><p>This abstract type is the parent of all transitions in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/events.jl#L6-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.SimulationFSM-Tuple{Any, Any}"><a class="docstring-binding" href="#ChronoSim.SimulationFSM-Tuple{Any, Any}"><code>ChronoSim.SimulationFSM</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SimulationFSM(physical_state, trans_rules; seed, rng, sampler, observer=nothing)</code></pre><p>Create a simulation.</p><p>The <code>physical_state</code> is of type <code>PhysicalState</code>. The sampler is of type <code>CompetingClocks.SSA</code>. The <code>trans_rules</code> are a list of type <code>SimEvent</code>. The seed is an integer seed for a <code>Xoshiro</code> random number generator. The observer is a callback with the signature:</p><pre><code class="language-julia hljs">observer(physical, when::Float64, event::SimEvent, changed_places::AbstractSet{Tuple})</code></pre><p>The <code>changed_places</code> argument is a set-like object with tuples that are keys that represent which places were changed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/framework.jl#L38-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.access_to_argnames-Tuple{Expr}"><a class="docstring-binding" href="#ChronoSim.access_to_argnames-Tuple{Expr}"><code>ChronoSim.access_to_argnames</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">access_to_argnames(expr)</code></pre><p>It extracts variable arguments to an accessor expression. An accessor expression uses <code>getfield</code> or <code>getindex</code> to find members of structs and containers. Turns this: <code>:(agent[j].value[k])</code>, into this: <code>[:(j), :(k)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/generators.jl#L218-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.access_to_searchkey-Tuple{Expr}"><a class="docstring-binding" href="#ChronoSim.access_to_searchkey-Tuple{Expr}"><code>ChronoSim.access_to_searchkey</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">access_to_searchkey(expr::Expr)</code></pre><p>Convert a Julia access expression into a search key pattern for the event generator system. Field names become <code>Member</code> objects, and array/container indices become <code>MEMBERINDEX</code> placeholders.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Simple member access
julia&gt; access_to_searchkey(:(obj.field))
[Member(:obj), Member(:field)]

# Array access with index
julia&gt; access_to_searchkey(:(arr[5].field))  
[Member(:arr), MEMBERINDEX, Member(:field)]

# Multi-dimensional array access
julia&gt; access_to_searchkey(:(board[i][j].piece))
[Member(:board), MEMBERINDEX, MEMBERINDEX, Member(:piece)]</code></pre><p>The resulting pattern is used to match against place keys in the simulation&#39;s state change tracking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/generators.jl#L168-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.capture_state_changes-Tuple{Function, Any}"><a class="docstring-binding" href="#ChronoSim.capture_state_changes-Tuple{Function, Any}"><code>ChronoSim.capture_state_changes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">capture_state_changes(f::Function, physical_state)</code></pre><p>The callback function <code>f</code> will modify the physical state. This function records which parts of the state were modified. The callback should have no arguments and may return a result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/physical_interface.jl#L48-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.capture_state_reads-Tuple{Function, Any}"><a class="docstring-binding" href="#ChronoSim.capture_state_reads-Tuple{Function, Any}"><code>ChronoSim.capture_state_reads</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">capture_state_reads(f::Function, physical_state)</code></pre><p>The callback function <code>f</code> will read the physical state. This function records which parts of the state were read. The callback should have no arguments and may return a result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/physical_interface.jl#L61-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.clock_key-Tuple{T} where T&lt;:SimEvent"><a class="docstring-binding" href="#ChronoSim.clock_key-Tuple{T} where T&lt;:SimEvent"><code>ChronoSim.clock_key</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clock_key(::SimEvent)::Tuple</code></pre><p>All <code>SimEvent</code> objects are immutable structs that represent events but don&#39;t carry any mutable state. A clock key is a tuple version of an event.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/events.jl#L88-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.common_base_key_tuple-Tuple{Any}"><a class="docstring-binding" href="#ChronoSim.common_base_key_tuple-Tuple{Any}"><code>ChronoSim.common_base_key_tuple</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Look at events and determine a common base type. Internally the simulation tracks events with sets of tuples by turning each event instance into a tuple. If all the tuples have the same type, this should turn out to be performant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/framework.jl#L25-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.deal_with_changes-Union{Tuple{CK}, Tuple{Sampler}, Tuple{State}, Tuple{SimulationFSM{State, Sampler, CK}, Any, Any, Any}} where {State, Sampler, CK}"><a class="docstring-binding" href="#ChronoSim.deal_with_changes-Union{Tuple{CK}, Tuple{Sampler}, Tuple{State}, Tuple{SimulationFSM{State, Sampler, CK}, Any, Any, Any}} where {State, Sampler, CK}"><code>ChronoSim.deal_with_changes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">deal_with_changes(sim::SimulationFSM, event_dependency, fired_event_keys, changed_places)</code></pre><p>An event changed the state. This function modifies events to respond to changes in state.</p><ul><li><code>sim</code> - the simulation</li><li><code>event_dependency</code> - the bipartite graph of addresses and clocks, separated out from the sim so that we can test more easily.</li><li><code>fired_event_keys</code> - a list of what fired. It&#39;s a list because of immediate events.</li><li><code>changed_places</code> - the addresses of physical state affected by firing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/framework.jl#L170-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.enable-Tuple{SimEvent, Any, Any}"><a class="docstring-binding" href="#ChronoSim.enable-Tuple{SimEvent, Any, Any}"><code>ChronoSim.enable</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enable(event, physical, when)</code></pre><p>Given that <code>precondition(event, physical)</code> is <code>true</code>, this determines the probability distribution for when the event might fire, starting from time <code>when</code>. We consider the returned tuple (probability distribution, offset time) a rate for the event. When <code>enable</code> is called, the framework tracks the specific physical addresses that were read in order to compute the rate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/events.jl#L24-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.escaped_args-Tuple{Any}"><a class="docstring-binding" href="#ChronoSim.escaped_args-Tuple{Any}"><code>ChronoSim.escaped_args</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Instead of escaping the argument list as-is, we reach into arguments that are tuples and escape them individually. The idea is to destructure the arguments into escaped variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/generators.jl#L254-L258">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.fire!-Tuple{SimEvent, Any, Any, Any}"><a class="docstring-binding" href="#ChronoSim.fire!-Tuple{SimEvent, Any, Any, Any}"><code>ChronoSim.fire!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fire!(event, physical, when, rng::AbstractRNG)</code></pre><p>When an event fires, it modifies state with this function. If you sample using the random number generator, that affects the likelihood of the outcome.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/events.jl#L67-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.fire!-Tuple{SimulationFSM, Any, Any}"><a class="docstring-binding" href="#ChronoSim.fire!-Tuple{SimulationFSM, Any, Any}"><code>ChronoSim.fire!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fire!(sim::SimulationFSM, time, event_key)</code></pre><p>Let the event act on the state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/framework.jl#L286-L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.generators-Tuple{Type{&lt;:SimEvent}}"><a class="docstring-binding" href="#ChronoSim.generators-Tuple{Type{&lt;:SimEvent}}"><code>ChronoSim.generators</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generators(::Type{SimEvent})::Vector{EventGenerator}</code></pre><p>Every transition in the simulation needs generators that notice changes to state or events fired and create the appropriate transitions. Implement a <code>generators</code> function as part of the interface of each transition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/generators.jl#L57-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.initialize!-Tuple{Any, Function, SimulationFSM}"><a class="docstring-binding" href="#ChronoSim.initialize!-Tuple{Any, Function, SimulationFSM}"><code>ChronoSim.initialize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Initialize the simulation. You could call it as a do-function. It is structured this way so that the simulation will record changes to the physical state.</p><pre><code class="language-julia hljs">    initialize!(sim) do init_physical
        initialize!(init_physical, agent_cnt, sim.rng)
    end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/framework.jl#L306-L315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.isconsistent-Tuple{PhysicalState}"><a class="docstring-binding" href="#ChronoSim.isconsistent-Tuple{PhysicalState}"><code>ChronoSim.isconsistent</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isconsistent(physical_state)</code></pre><p>A simulation in debug mode will assert <code>isconsistent(physical_state)</code> is true. Override this to verify the physical state of your simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/physical_interface.jl#L33-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.isimmediate-Tuple{Type{&lt;:SimEvent}}"><a class="docstring-binding" href="#ChronoSim.isimmediate-Tuple{Type{&lt;:SimEvent}}"><code>ChronoSim.isimmediate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isimmediate(EventType)</code></pre><p>An immediate event should return true for this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/events.jl#L81-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.key_clock-Tuple{Tuple, Dict{Symbol, DataType}}"><a class="docstring-binding" href="#ChronoSim.key_clock-Tuple{Tuple, Dict{Symbol, DataType}}"><code>ChronoSim.key_clock</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">key_clock(key::Tuple, event_dict::Dict{Symbol, DataType})::SimEvent</code></pre><p>Takes a tuple of the form (:symbol, arg, arg) and a dictionary mapping symbols to struct types, and returns an instantiation of the struct named by :symbol. We pass in the list of datatypes because, if we didn&#39;t, then instantiation of a type from a symbol would need to search for the correct constructor in the correct module, and that would be both wrong and slow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/events.jl#L100-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.over_event_rates-Tuple{Function, ChronoSim.EventDependency, Any, Any, Any}"><a class="docstring-binding" href="#ChronoSim.over_event_rates-Tuple{Function, ChronoSim.EventDependency, Any, Any, Any}"><code>ChronoSim.over_event_rates</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Note that this method requires a first call to <code>over_event_invariants</code> and that this method interacts with that call by excluding events that were iterated in <code>over_event_invariants</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/placetoevent.jl#L48-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.over_generated_events-Tuple{Function, GeneratorSearch, Any, Any, Any}"><a class="docstring-binding" href="#ChronoSim.over_generated_events-Tuple{Function, GeneratorSearch, Any, Any, Any}"><code>ChronoSim.over_generated_events</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">over_generated_events(callback, generators, physical, event_keys, changed_places)</code></pre><ul><li><code>callback</code> is a function in the main event loop of the framework that accepts an event as an argument.</li><li><code>generators</code> is the struct containing all event generators.</li><li><code>physical</code> is physical state.</li><li><code>event_keys</code> is a vector or set of keys.</li><li><code>changed_places</code> is a vector or set of physical addresses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/generators.jl#L101-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.over_generated_events-Tuple{Function, Vararg{Any, 4}}"><a class="docstring-binding" href="#ChronoSim.over_generated_events-Tuple{Function, Vararg{Any, 4}}"><code>ChronoSim.over_generated_events</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">over_generated_events(f::Function, generators, physical, fired_event_key, changed_places)</code></pre><p>Given a fired event and the set of places changed by that event, create new events that may depend on that fired event and those changed places.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/generator_interface.jl#L3-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.over_tracked_physical_state-Union{Tuple{T}, Tuple{Function, T}} where T&lt;:PhysicalState"><a class="docstring-binding" href="#ChronoSim.over_tracked_physical_state-Union{Tuple{T}, Tuple{Function, T}} where T&lt;:PhysicalState"><code>ChronoSim.over_tracked_physical_state</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">over_tracked_physical_state(fcallback::Function, physical::PhysicalState)</code></pre><p>Iterate over all tracked vectors in the physical state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/physical_interface.jl#L41-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.precondition-Tuple{SimEvent, Any}"><a class="docstring-binding" href="#ChronoSim.precondition-Tuple{SimEvent, Any}"><code>ChronoSim.precondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">precondition(event, physical_state)</code></pre><p>This determines whether an event should be in the enabled state given the current physical state. When this method is called, the framework tracks the specific addresses of the physical state that were read in order to determine whether this event should be enabled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/events.jl#L13-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.reenable-Tuple{SimEvent, Any, Any, Any}"><a class="docstring-binding" href="#ChronoSim.reenable-Tuple{SimEvent, Any, Any, Any}"><code>ChronoSim.reenable</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reenable(event, physical, first_enabled, when)</code></pre><p>Called for events that were enabled before a state change and remain enabled after. The framework has already verified the precondition still passes. This function determines whether the event&#39;s distribution needs to be updated in the sampler.</p><p>Three conditions determine whether to call <code>reenable</code>:</p><ul><li>Invariant - A place read by <code>precondition</code> was modified by <code>fire!</code>.</li><li>Addresses - The <code>precondition</code> now reads different places than before (relative event).</li><li>Rate - A place read by <code>enable</code> was modified by <code>fire!</code>.</li></ul><table><tr><th style="text-align: right">Invariant</th><th style="text-align: right">Addresses</th><th style="text-align: right">Rate</th><th style="text-align: right">reenable?</th><th style="text-align: right">Reason</th></tr><tr><td style="text-align: right">✅</td><td style="text-align: right">❌</td><td style="text-align: right">❌</td><td style="text-align: right">❌</td><td style="text-align: right">Same places, precondition still holds, rate unaffected</td></tr><tr><td style="text-align: right">✅</td><td style="text-align: right">❌</td><td style="text-align: right">✅</td><td style="text-align: right">✅</td><td style="text-align: right">Same places, precondition still holds, rate unaffected</td></tr><tr><td style="text-align: right">✅</td><td style="text-align: right">✅</td><td style="text-align: right">—</td><td style="text-align: right">✅</td><td style="text-align: right">Relative event: dependencies shifted to new places</td></tr><tr><td style="text-align: right">❌</td><td style="text-align: right">❌</td><td style="text-align: right">✅</td><td style="text-align: right">✅</td><td style="text-align: right">Rate dependencies changed</td></tr><tr><td style="text-align: right">❌</td><td style="text-align: right">❌</td><td style="text-align: right">❌</td><td style="text-align: right">❌</td><td style="text-align: right">Nothing relevant changed</td></tr></table><p>Key: ✅ = changed, ❌ = unchanged, — = doesn&#39;t matter</p><p>The default implementation returns <code>nothing</code> (no update needed). To update the distribution, forward to <code>enable</code>:</p><pre><code class="language-julia hljs">reenable(e::MyEvent, phys, _, t) = enable(e, phys, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/events.jl#L35-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.run-Tuple{SimulationFSM, SimEvent, Function, Function}"><a class="docstring-binding" href="#ChronoSim.run-Tuple{SimulationFSM, SimEvent, Function, Function}"><code>ChronoSim.run</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run(simulation, initializer, stop_condition)</code></pre><p>Given a simulation, this initializes the physical state and generates a trajectory from the simulation until the stop condition is met. The <code>initializer</code> is either a function whose argument is a physical state and returns nothing, or it is an event key for an event that initializes the system. The stop condition is a function with the signature:</p><pre><code class="language-julia hljs">stop_condition(physical_state, step_idx, event::SimEvent, when)::Bool</code></pre><p>The event and when passed into the stop condition are the event and time that are about to fire but have not yet fired. This lets you enforce a stopping time that is between events.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/framework.jl#L327-L343">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.sim_event_precondition-Tuple{SimEvent, Any}"><a class="docstring-binding" href="#ChronoSim.sim_event_precondition-Tuple{SimEvent, Any}"><code>ChronoSim.sim_event_precondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The three <code>sim_event_*</code> functions call user-defined code, so we separate this out in order to check the calls and return values. This also provides a way to mock interaction with both events and the sampler for testing the central function <code>deal_with_changes()</code>. Subclass <code>SimEvent</code> to create a fake interaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/framework.jl#L121-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.trace_likelihood-Tuple{SimulationFSM, SimEvent, Function, Any}"><a class="docstring-binding" href="#ChronoSim.trace_likelihood-Tuple{SimulationFSM, SimEvent, Function, Any}"><code>ChronoSim.trace_likelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The <code>trace</code> is a <code>Vector{Tuple{Float64,SimEvent}}</code>. That is, it&#39;s a list of tuples containing <code>(when, what event)</code>. In order to calculate log-likelihood of a simulation, pass it a sampler that tracks log-likelihood. For instance,</p><pre><code class="language-julia hljs">base_sampler = CombinedNextReaction{K,T}()
memory_sampler = MemorySampler(base_sampler)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/framework.jl#L373-L382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.@conditionsfor-Tuple{Any, Any}"><a class="docstring-binding" href="#ChronoSim.@conditionsfor-Tuple{Any, Any}"><code>ChronoSim.@conditionsfor</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@conditionsfor EventType begin
    @reactto ... end
    @reactto ... end
end</code></pre><p>Generates a generators(::Type{EventType}) function containing all the EventGenerators defined in the @reactto blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/generators.jl#L376-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.@reactto-Tuple{Any}"><a class="docstring-binding" href="#ChronoSim.@reactto-Tuple{Any}"><code>ChronoSim.@reactto</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@reactto changed(array[index].field) do physical
    # generator body
end

@reactto fired(EventType(args...)) do physical
    # generator body
end</code></pre><p>Creates an EventGenerator that reacts to state changes or event firings. Used within @conditionsfor blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/generators.jl#L278-L289">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.ObservedState.Address"><a class="docstring-binding" href="#ChronoSim.ObservedState.Address"><code>ChronoSim.ObservedState.Address</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Address{Key}()</code></pre><p>Represents the address of this compound struct within the container that has this object. This object is mutable because addresses change as containers modify their contents.</p><p>If this object is in a vector, the <code>Key=Int</code>. If it&#39;s in a struct, <code>Key=Member</code>, which is a wrapper around the fieldname Symbol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/ObservedState/obs_traits.jl#L25-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.ObservedState.ObservedSet"><a class="docstring-binding" href="#ChronoSim.ObservedState.ObservedSet"><code>ChronoSim.ObservedState.ObservedSet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ObservedSet{T,Key} &lt;: AbstractSet{T}</code></pre><p>A set that tracks mutations for the ChronoSim observed state system. Unlike ObservedVector and ObservedDict, ObservedSet is not a container -  elements within the set do not have addresses and cannot be individually tracked.</p><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Element type of the set</li><li><code>Key</code>: The type of index this set has within its parent container  (e.g., <code>Member</code> for struct fields, <code>Int</code> for vector elements)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># In an observed struct
@observedphysical GameState begin
    buildings::ObservedSet{String,Member}
end

# In an observed vector  
floors = ObservedVector{ObservedSet{String,Int}}(undef, 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/ObservedState/observed_set.jl#L4-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Tuple{IO, ChronoSim.ObservedState.Address}"><a class="docstring-binding" href="#Base.show-Tuple{IO, ChronoSim.ObservedState.Address}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The show() function for <code>Address{Key}</code> doesn&#39;t print the container because the type can be quite large.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/ObservedState/obs_traits.jl#L41-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.ObservedState.access_to_placekey-Tuple{Expr}"><a class="docstring-binding" href="#ChronoSim.ObservedState.access_to_placekey-Tuple{Expr}"><code>ChronoSim.ObservedState.access_to_placekey</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">access_to_placekey(expr)</code></pre><p>This function takes an expression for member access to a hierarchical container and converts it into a place key. For instance:</p><table><tr><th style="text-align: right">Accessor expression</th><th style="text-align: right">Place key</th></tr><tr><td style="text-align: right"><code>state.agent[j].armor</code></td><td style="text-align: right"><code>(:agent, j, :armor)</code></td></tr><tr><td style="text-align: right"><code>sim.board[i, j].fval</code></td><td style="text-align: right"><code>(:board, (i, j), :fval)</code></td></tr><tr><td style="text-align: right"><code>state.param</code></td><td style="text-align: right"><code>(:param,)</code></td></tr><tr><td style="text-align: right"><code>sim.adict[(name, kind)]</code></td><td style="text-align: right"><code>(:adict, (name, kind))</code></td></tr><tr><td style="text-align: right"><code>physical.land[square].grass</code></td><td style="text-align: right"><code>(:land, square, :grass)</code></td></tr></table><p>The output is also an <code>Expr</code>-type object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/ObservedState/observe_macro.jl#L1-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.ObservedState.notify_all-Tuple{Any}"><a class="docstring-binding" href="#ChronoSim.ObservedState.notify_all-Tuple{Any}"><code>ChronoSim.ObservedState.notify_all</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">notify_all(obj)</code></pre><p>e When a struct is deleted or has its index changed, it should create a notification for every member of the struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/ObservedState/keyed.jl#L4-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.capture_state_changes-Tuple{Function, ChronoSim.ObservedState.ObservedPhysical}"><a class="docstring-binding" href="#ChronoSim.capture_state_changes-Tuple{Function, ChronoSim.ObservedState.ObservedPhysical}"><code>ChronoSim.capture_state_changes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">capture_state_changes(f::Function, physical_state)</code></pre><p>The callback function <code>f</code> will modify the physical state. This function records which parts of the state were modified. The callback should have no arguments and may return a result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/ObservedState/observed_physical.jl#L171-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.capture_state_reads-Tuple{Function, ChronoSim.ObservedState.ObservedPhysical}"><a class="docstring-binding" href="#ChronoSim.capture_state_reads-Tuple{Function, ChronoSim.ObservedState.ObservedPhysical}"><code>ChronoSim.capture_state_reads</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">capture_state_reads(f::Function, physical_state)</code></pre><p>The callback function <code>f</code> will read the physical state. This function records which parts of the state were read. The callback should have no arguments and may return a result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/ObservedState/observed_physical.jl#L186-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.ObservedState.@keyedby-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#ChronoSim.ObservedState.@keyedby-Tuple{Any, Any, Any}"><code>ChronoSim.ObservedState.@keyedby</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@keyedby StructName IndexType begin
    field1::Type1
    field2::Type2
    ...
end</code></pre><p>Create a mutable struct with the given fields plus automatic <code>_container::Any</code> and <code>_index::IndexType</code> fields. The generated constructor only requires the user-defined fields.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@keyedby MyElement Int64 begin
    val::Int64
    name::String
end</code></pre><p>This generates a struct equivalent to:</p><pre><code class="language-julia hljs">mutable struct MyElement &lt;: Addressed
    val::Int64
    name::String
    _address::Address{Int64}
    MyElement(val, name) = new(val, name)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/ObservedState/keyed.jl#L63-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.ObservedState.@observedphysical-Tuple{Any, Any}"><a class="docstring-binding" href="#ChronoSim.ObservedState.@observedphysical-Tuple{Any, Any}"><code>ChronoSim.ObservedState.@observedphysical</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@observedphysical &lt;typename&gt; &lt;definition block&gt;</code></pre><p>This macro defines a physical state that uses the ObservedState machinery to track changes to that physical state.</p><p>For example:</p><pre><code class="language-julia hljs">@keyedby Int Piece begin
    speed::Float64
    kind::String
end

@keyedby NTuple{2,Int64} Square begin
    grass::Float64
    food::Float64
end

@observedphysical Board begin
    board::ObservedArray{Square,2}
    actor::ObservedDict{Int,Piece}
    params::Dict{Symbol,Float64}
    actors_max::Int64
end</code></pre><p>This macro creates a struct that contains tracking information about its Observed members, so in the example <code>params</code> would not be tracked. The <code>Board</code> type has a parent type <code>ObservedPhysical</code> which has the parent type <code>ChronoSim.PhysicalState</code>.</p><p>Expanding the macro, we would see:</p><pre><code class="language-julia hljs">mutable struct Board &lt;: ObservedPhysical
    board::ObservedArray{Square,2}
    actor::ObservedDict{Int,Piece}
    params::Dict{Symbol,Float64}
    actors_max::Int64
    obs_modified::Vector{Tuple}
    obs_read::Vector{Tuple}
    Board(board, actor, params, actors_max) = ...
end</code></pre><p>Here, the list of read and modified state uses the abstract type <code>Tuple</code> because it unifies the way changed state is reported for the two observed containers: <code>(:board, (2,2), :grass)</code> and <code>(:actor, 7, :speed)</code>. The ellipsis above for the constructor is a constructor that initializes <code>obs_modified</code> and <code>obs_read</code> to empty vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/ObservedState/observed_physical.jl#L11-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.ObservedState.@obsread-Tuple{Any}"><a class="docstring-binding" href="#ChronoSim.ObservedState.@obsread-Tuple{Any}"><code>ChronoSim.ObservedState.@obsread</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@obsread expr</code></pre><p>Track reads and writes to ObservedPhysical state. Records the access in physical state and returns the value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/ObservedState/observe_macro.jl#L78-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ChronoSim.ObservedState.@obswrite-Tuple{Any}"><a class="docstring-binding" href="#ChronoSim.ObservedState.@obswrite-Tuple{Any}"><code>ChronoSim.ObservedState.@obswrite</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@obswrite expr</code></pre><p>Track writes to ObservedPhysical state. Records the access in physical state and performs the assignment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/ChronoSim.jl/blob/0c46340f9700407fd1e6f811e6ef39340419bede/src/ObservedState/observe_macro.jl#L89-L94">source</a></section></details></article><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../categorize/">« Category of Simulation</a><a class="docs-footer-nextpage" href="../plan/">Plan »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 7 December 2025 18:58">Sunday 7 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
