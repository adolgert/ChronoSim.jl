<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plan · ChronoSim.jl</title><meta name="title" content="Plan · ChronoSim.jl"/><meta property="og:title" content="Plan · ChronoSim.jl"/><meta property="twitter:title" content="Plan · ChronoSim.jl"/><meta name="description" content="Documentation for ChronoSim.jl."/><meta property="og:description" content="Documentation for ChronoSim.jl."/><meta property="twitter:description" content="Documentation for ChronoSim.jl."/><meta property="og:url" content="https://adolgert.github.io/ChronoSim.jl/plan/"/><meta property="twitter:url" content="https://adolgert.github.io/ChronoSim.jl/plan/"/><link rel="canonical" href="https://adolgert.github.io/ChronoSim.jl/plan/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ChronoSim.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">ChronoSim</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../not_chrono/">Why Not Hand Made</a></li><li><a class="tocitem" href="../whatitis/">What It Does</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Simulation State</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../observedphysical/">Struct of Observed Vectors and Arrays</a></li><li><a class="tocitem" href="../observedmacro/">The @observe Macro</a></li><li><a class="tocitem" href="../customstate/">Custom State</a></li></ul></li><li><a class="tocitem" href="../categorize/">Category of Simulation</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><span class="tocitem">Development</span><ul><li class="is-active"><a class="tocitem" href>Plan</a><ul class="internal"><li><a class="tocitem" href="#Why-use-this?"><span>Why use this?</span></a></li><li><a class="tocitem" href="#Current-Capabilities"><span>Current Capabilities</span></a></li><li><a class="tocitem" href="#Future-Capabilities"><span>Future Capabilities</span></a></li><li><a class="tocitem" href="#Reframing-as-propagator"><span>Reframing as propagator</span></a></li><li><a class="tocitem" href="#Main-Pain-Points"><span>Main Pain Points</span></a></li><li><a class="tocitem" href="#Improvements-to-the-Framework-User-Interface"><span>Improvements to the Framework User Interface</span></a></li><li><a class="tocitem" href="#Sample-Implementation"><span>Sample Implementation</span></a></li></ul></li><li><a class="tocitem" href="../event_update/">Event Updates</a></li><li><a class="tocitem" href="../architecture_diagram/">Architecture</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Development</a></li><li class="is-active"><a href>Plan</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Plan</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/ChronoSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/ChronoSim.jl/blob/main/docs/src/plan.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Plan"><a class="docs-heading-anchor" href="#Plan">Plan</a><a id="Plan-1"></a><a class="docs-heading-anchor-permalink" href="#Plan" title="Permalink"></a></h1><p>This simulation framework asks a question: How can we simulate with time-varying hazards and get full expressiveness and statistical capability?</p><h3 id="Problems-We-Want-to-Solve"><a class="docs-heading-anchor" href="#Problems-We-Want-to-Solve">Problems We Want to Solve</a><a id="Problems-We-Want-to-Solve-1"></a><a class="docs-heading-anchor-permalink" href="#Problems-We-Want-to-Solve" title="Permalink"></a></h3><ul><li>GSPN requires building a large graph before simulating, and creating versions of a simulation requires creating versions of those graphs. It is painstaking.</li><li>GSMP historically use Exponential distributions or have limited ideas of what a hazard rate can be and a limited definition of state. But this IS a GSMP by its statistical definition.</li><li>Chemical simulation with time-varying hazards does happen. It&#39;s just restricted to particular forms for the hazard rates and a limited definition of state (counts of chemicals). It&#39;s not wrong, but it doesn&#39;t do arbitrary, real-valued state.</li></ul><h3 id="This-framework-has-an-opinion"><a class="docs-heading-anchor" href="#This-framework-has-an-opinion">This framework has an opinion</a><a id="This-framework-has-an-opinion-1"></a><a class="docs-heading-anchor-permalink" href="#This-framework-has-an-opinion" title="Permalink"></a></h3><ol><li><p><strong>Which events are enabled and disabled will be mediated by changes to a state.</strong> This is in contrast to a simulation where a firing function, within that function, will enable and disable events.</p></li><li><p><strong>Events will be created dynamically based on the state.</strong> There is a way to avoid construction of the bipartite graph of the Petri net.</p></li></ol><p>Both of these points exist to make it easier to <strong>compose simulations.</strong> They also enable us to use a simulation as a statistical evaluator of likelihoods of trajectories. We will, for instance, be able to modify a simulation by specifying a list of events to include in the simulation, substituting one event for another.</p><h3 id="This-framework-asks-questions"><a class="docs-heading-anchor" href="#This-framework-asks-questions">This framework asks questions</a><a id="This-framework-asks-questions-1"></a><a class="docs-heading-anchor-permalink" href="#This-framework-asks-questions" title="Permalink"></a></h3><ol><li><p>Is there a simulation component that will update state and clocks correctly in a way that helps write simulations but doesn&#39;t limit the kinds of uses? I mean is there some set of features we want in the state update that supports different applications like chemical simulation, disease simulation, reliability, etc?</p></li><li><p>How can we define simulation state in a way that is a) observable by the framework and b) can be transactional so we can roll back changes to the state?</p></li><li><p>What are design patterns for dynamic generation of events from the state?</p></li><li><p>How can we make a framework that can be the base for a problem-specific DSL made with macros?</p></li></ol><h2 id="Why-use-this?"><a class="docs-heading-anchor" href="#Why-use-this?">Why use this?</a><a id="Why-use-this?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-use-this?" title="Permalink"></a></h2><ol><li>Curiosity to see how well/badly it works.</li><li>Get ideas to do something different.</li><li>You have a sincerely difficult simulation problem, and this is the best expression of it.</li></ol><h2 id="Current-Capabilities"><a class="docs-heading-anchor" href="#Current-Capabilities">Current Capabilities</a><a id="Current-Capabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Capabilities" title="Permalink"></a></h2><iframe src="assets/d3_event_diagram.html" style="width: 100%; height: 500px; border: none;"></iframe><h3 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h3><ol><li>Rule-based events</li><li>Sampling methods</li><li>Dirac delta function times (for ODEs)</li><li>Deterministic once random seed is set.</li><li>Re-enabling of events</li><li>Rules that depend on events instead of just states.<ul><li>Macro and struct for event(key)</li></ul></li><li>Observers on events</li><li>Observers of state changes</li><li>Immediate events</li></ol><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><ol><li>Elevators with TLA+.</li><li>Reliability with a set of trucks.</li><li>SIR with strain mutation and individual movement models.</li><li>Movement through a 2D domain for particle filtering.</li></ol><h3 id="Known-bugs"><a class="docs-heading-anchor" href="#Known-bugs">Known bugs</a><a id="Known-bugs-1"></a><a class="docs-heading-anchor-permalink" href="#Known-bugs" title="Permalink"></a></h3><ol><li>Observe macro needs hygiene to evaluate methods in defining context.</li></ol><h2 id="Future-Capabilities"><a class="docs-heading-anchor" href="#Future-Capabilities">Future Capabilities</a><a id="Future-Capabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Future-Capabilities" title="Permalink"></a></h2><h3 id="Features-2"><a class="docs-heading-anchor" href="#Features-2">Features</a><a class="docs-heading-anchor-permalink" href="#Features-2" title="Permalink"></a></h3><ol><li>Clarify in docs that this is a model + propagator, not a framework.</li><li>Importance sampling</li><li><code>fire!()</code> uses probabilistic programming to get complete likelihood.</li><li>The user can supply a list of all events in order to build a complete depnet before simulating.</li><li>Pregeneration of all rule-based events.</li><li>Transactional firing (for estimation of derivatives)</li><li>MCMC sampling from trajectories</li><li>Simulate backwards in time.</li></ol><h3 id="Example-Simulations"><a class="docs-heading-anchor" href="#Example-Simulations">Example Simulations</a><a id="Example-Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Simulations" title="Permalink"></a></h3><ol><li>Move, infect, age, birth.</li><li>Policy-driven movement.</li><li>Queuing model.</li><li>Chemical equations.</li><li>Drone search pattern with geometry.</li><li>HMC for house-to-house infestation.</li><li>Job shop problem.</li><li>Cars driving on a map.</li></ol><h3 id="Example-Uses-of-Simulations"><a class="docs-heading-anchor" href="#Example-Uses-of-Simulations">Example Uses of Simulations</a><a id="Example-Uses-of-Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Uses-of-Simulations" title="Permalink"></a></h3><ol><li>Hook into standard Julia analysis tools.</li><li>Sampling rare events.</li><li>Parameter fitting to world data.</li><li>Optimization of parameters to minimize a goal function.</li><li>HMC on trajectories to find a most likely event stream.</li><li>POMDP</li></ol><h3 id="Performance-Questions"><a class="docs-heading-anchor" href="#Performance-Questions">Performance Questions</a><a id="Performance-Questions-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Questions" title="Permalink"></a></h3><ol><li>How stable can I make the type system in the running simulation? It uses Events in places and tuples in others.</li><li>The TrackedEntry needs to be timed and gamed.</li><li>Could the TrackedEntry be an N-dimensional array? Could each entry be an array? A dictionary?</li><li>Can the main simulation look over the keys to determine types before it instantiates?</li><li>The depnet is absolutely wrong for the current main loop. It might be closer to right for another mainloop. Should try various implementations.</li><li>Measure performance with profiling. Look for the memory leaks.</li></ol><h2 id="Reframing-as-propagator"><a class="docs-heading-anchor" href="#Reframing-as-propagator">Reframing as propagator</a><a id="Reframing-as-propagator-1"></a><a class="docs-heading-anchor-permalink" href="#Reframing-as-propagator" title="Permalink"></a></h2><p>Three concepts around which to structure:</p><ol><li>Event Propagation: Given current state and enabled events, calculate the probability distribution over next events</li><li>Likelihood Calculation: Compute the exact probability of observed event sequences (for model fitting)</li><li>Compositional Integration: Use as a component within larger statistical or numerical analyses</li></ol><h2 id="Main-Pain-Points"><a class="docs-heading-anchor" href="#Main-Pain-Points">Main Pain Points</a><a id="Main-Pain-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Pain-Points" title="Permalink"></a></h2><p>The central idea is that a Model is a set of events mediated by their interaction with state. We insist on this central idea by forbidding a user from creating events in a firing function. It must always be the case that, given a simulation state, it is possible to apply events to it and figure out which are or aren&#39;t enabled. This is what makes the system a weak Markov system. It&#39;s a limitation that we should be able to turn into a strength. I&#39;m not sure how though.</p><ol><li><p>There is a tenuous connection from an updated state to the generators that see that state and connect it to events.</p><ul><li>One debugging move: Always execute every enabling invariant at every step. If one is a yes but its generator didn&#39;t fire, then that&#39;s a problem.</li></ul></li><li><p>There are at least five separate definitions to create an Event. That&#39;s a lot to do. Is it easy to understand or can we reduce complexity?</p></li><li><p>I know from experience that debugging these simulations is very difficult. Is there some idea I&#39;m missing that would elucidate why some event failed to fire or why an event fires when you don&#39;t think it should?</p><ul><li><code>A</code> fired, so why wasn&#39;t <code>B</code> enabled? This is hard to track because <code>A</code> affects state, and maybe <code>B</code> doesn&#39;t see that state.</li><li>We could have the address of everything written and read. Relate it to what&#39;s in the network, like a local graph.</li></ul></li></ol><h2 id="Improvements-to-the-Framework-User-Interface"><a class="docs-heading-anchor" href="#Improvements-to-the-Framework-User-Interface">Improvements to the Framework User Interface</a><a id="Improvements-to-the-Framework-User-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Improvements-to-the-Framework-User-Interface" title="Permalink"></a></h2><p>This section is from conversations with AI about the spectrum of ways to improve the user interface. There were some good ideas in there so they are recorded here.</p><h3 id="The-Five-parts"><a class="docs-heading-anchor" href="#The-Five-parts">The Five parts</a><a id="The-Five-parts-1"></a><a class="docs-heading-anchor-permalink" href="#The-Five-parts" title="Permalink"></a></h3><table><tr><th style="text-align: right">Component</th><th style="text-align: right">Role</th></tr><tr><td style="text-align: right">Events</td><td style="text-align: right">The SimEvent interface (precondition, enable, reenable, fire!, isimmediate)</td></tr><tr><td style="text-align: right">Generators</td><td style="text-align: right">The reactive system that creates events from state changes or other events (@reactto, @conditionsfor)</td></tr><tr><td style="text-align: right">Observable State</td><td style="text-align: right">Containers that track reads/writes (ObservedArray, ObservedDict, etc.)</td></tr><tr><td style="text-align: right">Dependency Network</td><td style="text-align: right">Bidirectional graph: which events depend on which state &quot;places&quot;</td></tr><tr><td style="text-align: right">SimulationFSM</td><td style="text-align: right">The orchestrator that coordinates all of the above with CompetingClocks</td></tr></table><ol><li>Where does complexity live today? The plan.md lists many UX improvements (macros, traits, templates). Is the current interface genuinely</li></ol><p>difficult, or is it just verbose? There&#39;s a difference between &quot;hard to understand&quot; and &quot;tedious to write.&quot;</p><ol><li>The Observer pattern: You have observers on state and observers on events (the observer callback in SimulationFSM). How do users think about</li></ol><p>these? Are they fundamentally different, or could they unify?</p><ol><li>Likelihood calculation: The trace_likelihood and steploglikelihood integration suggests you&#39;re targeting inference/estimation workloads. Is that</li></ol><p>a primary use case or secondary?</p><h3 id="generator-functions-use-do-function-syntax-so-make-it-easier."><a class="docs-heading-anchor" href="#generator-functions-use-do-function-syntax-so-make-it-easier.">generator functions use do-function syntax so make it easier.</a><a id="generator-functions-use-do-function-syntax-so-make-it-easier.-1"></a><a class="docs-heading-anchor-permalink" href="#generator-functions-use-do-function-syntax-so-make-it-easier." title="Permalink"></a></h3><p>Create a macro for generator functions that looks like you call <code>generate(event)</code> but really calls a do-function callback underneath.</p><h3 id="Simplify-enabling/reenabling"><a class="docs-heading-anchor" href="#Simplify-enabling/reenabling">Simplify enabling/reenabling</a><a id="Simplify-enabling/reenabling-1"></a><a class="docs-heading-anchor-permalink" href="#Simplify-enabling/reenabling" title="Permalink"></a></h3><p>Ask the simulation to define the distribution and when but not the sampler, rng, or clock_key.</p><h3 id="Explicitly-register-functions"><a class="docs-heading-anchor" href="#Explicitly-register-functions">Explicitly register functions</a><a id="Explicitly-register-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Explicitly-register-functions" title="Permalink"></a></h3><p>In framework.jl - automatic method generation   function register<em>event(event</em>type::Type{&lt;:SimEvent}, spec::EventSpec)       # Generate precondition, generators, enable, fire! automatically       # Based on declarative specification   end</p><h3 id="Macro-to-say-what-generators-trigger-on"><a class="docs-heading-anchor" href="#Macro-to-say-what-generators-trigger-on">Macro to say what generators trigger on</a><a id="Macro-to-say-what-generators-trigger-on-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-to-say-what-generators-trigger-on" title="Permalink"></a></h3><p>Framework provides path builder   @watches actors[<em>].state  # Instead of [:actors, ℤ, :state]   @watches board[</em>].occupant</p><h3 id="Put-common-event-patterns-into-template-structs"><a class="docs-heading-anchor" href="#Put-common-event-patterns-into-template-structs">Put common event patterns into template structs</a><a id="Put-common-event-patterns-into-template-structs-1"></a><a class="docs-heading-anchor-permalink" href="#Put-common-event-patterns-into-template-structs" title="Permalink"></a></h3><p>Framework could provide base types:</p><ul><li>ActorEvent{T} - for single-actor events</li><li>InteractionEvent{T} - for multi-actor events</li><li>ScheduledEvent{T} - for time-based events</li><li>StateTransitionEvent{T} - for state machine transitions</li></ul><p>or make it a function:   Framework provides factory for common patterns   create<em>state</em>transition<em>event(       :Break,       from</em>state = :working,       to<em>state = :broken,       rate</em>field = :fail<em>dist,       age</em>tracking = true   )</p><h3 id="Put-common-enabling-patterns-into-template-structs"><a class="docs-heading-anchor" href="#Put-common-enabling-patterns-into-template-structs">Put common enabling patterns into template structs</a><a id="Put-common-enabling-patterns-into-template-structs-1"></a><a class="docs-heading-anchor-permalink" href="#Put-common-enabling-patterns-into-template-structs" title="Permalink"></a></h3><p>Common patterns built into framework   abstract type RateModel end   struct ConstantRate &lt;: RateModel; dist; end   struct ActorRate &lt;: RateModel; field::Symbol; end   struct TimeBasedRate &lt;: RateModel; calc::Function; end</p><h3 id="Help-build-the-simulation-itself"><a class="docs-heading-anchor" href="#Help-build-the-simulation-itself">Help build the simulation itself</a><a id="Help-build-the-simulation-itself-1"></a><a class="docs-heading-anchor-permalink" href="#Help-build-the-simulation-itself" title="Permalink"></a></h3><p>In framework.jl   @simulation MySimulation begin       state_type = IndividualState       events = [StartDay, EndDay, Break, Repair]       sampler = CombinedNextReaction</p><pre><code class="nohighlight hljs">  initialize = function(physical, rng)
      # initialization code
  end

  stop_when = (physical, step, event, when) -&gt; when &gt; days</code></pre><p>end</p><h3 id="Make-tools-with-which-to-make-simulation-DSLs"><a class="docs-heading-anchor" href="#Make-tools-with-which-to-make-simulation-DSLs">Make tools with which to make simulation DSLs</a><a id="Make-tools-with-which-to-make-simulation-DSLs-1"></a><a class="docs-heading-anchor-permalink" href="#Make-tools-with-which-to-make-simulation-DSLs" title="Permalink"></a></h3><pre><code class="nohighlight hljs">  # Framework should export these primitives
  export create_generator, register_precondition, add_rate_function
  export EventSpecification, GeneratorSpec, RateSpec

  # So users can build their own DSLs:
  macro my_reliability_event(name, spec)
      quote
          struct $(esc(name)) &lt;: ActorEvent{IndividualState}
              actor_idx::Int
          end

          # Use framework primitives
          register_precondition($(esc(name)), $(spec.precondition))
          add_rate_function($(esc(name)), $(spec.rate))
      end
  end</code></pre><h3 id="Use-traits-more-than-inheritance"><a class="docs-heading-anchor" href="#Use-traits-more-than-inheritance">Use traits more than inheritance</a><a id="Use-traits-more-than-inheritance-1"></a><a class="docs-heading-anchor-permalink" href="#Use-traits-more-than-inheritance" title="Permalink"></a></h3><p>Maybe both traits and hooks, where a user registers a function to call for a particular event.</p><pre><code class="nohighlight hljs">  # Framework defines traits
  abstract type EventTrait end
  struct HasActor &lt;: EventTrait end
  struct HasSchedule &lt;: EventTrait end
  struct HasInteraction &lt;: EventTrait end

  # Users can mix traits freely
  event_traits(::Type{&lt;:SimEvent}) = ()
  event_traits(::Type{Break}) = (HasActor(), HasSchedule())

  # Framework dispatches on traits
  function generate_precondition(evt::Type{T}) where T
      traits = event_traits(T)
      # Compose behavior from traits
  end</code></pre><p>This could also help the functions on events.</p><pre><code class="nohighlight hljs">  # Instead of storing functions, use traits
  abstract type PreconditionTrait end
  struct StateCheck{S} &lt;: PreconditionTrait
      required_state::S
  end

  struct EventConfig{P &lt;: PreconditionTrait}
      precondition_trait::P
  end

  # Fast dispatch
  @inline function check_precondition(evt::ActorEvent, physical, ::StateCheck{S}) where S
      physical.actors[evt.actor_idx].state == S
  end</code></pre><h3 id="Make-Syntax-Trees-Accessible"><a class="docs-heading-anchor" href="#Make-Syntax-Trees-Accessible">Make Syntax Trees Accessible</a><a id="Make-Syntax-Trees-Accessible-1"></a><a class="docs-heading-anchor-permalink" href="#Make-Syntax-Trees-Accessible" title="Permalink"></a></h3><pre><code class="nohighlight hljs">  # If framework uses macros, expose the AST
  macro framework_helper(expr)
      ast = parse_event_ast(expr)
      # Let users transform it
      transformed = apply_user_transforms(ast)
      return generate_code(transformed)
  end

  # Users can register transforms
  register_ast_transform!(my_reliability_transform)</code></pre><h3 id="Macro-advice"><a class="docs-heading-anchor" href="#Macro-advice">Macro advice</a><a id="Macro-advice-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-advice" title="Permalink"></a></h3><p>Macro Design Best Practices</p><p>AVOID These Patterns:</p><pre><code class="nohighlight hljs">  # 1. Rigid syntax requirements
  @framework_event name::Type = value  # Forces specific syntax

  # 2. Closed evaluation contexts
  @framework_event Break begin
      eval(:(struct Break ... end))  # Evaluates in framework module
  end

  # 3. Monolithic macros
  @define_entire_event Break working broken fail_dist ...</code></pre><p>PREFER These Patterns:</p><pre><code class="nohighlight hljs">  # 1. Composable macro fragments
  @event_struct Break actor_idx::Int
  @event_precondition Break (evt, phys) -&gt; phys.actors[evt.actor_idx].state == working
  @event_rate Break (evt, phys) -&gt; phys.params[evt.actor_idx].fail_dist

  # 2. Pass-through to user context
  macro framework_helper(name, user_expr)
      quote
          # Evaluate in caller&#39;s context
          local user_result = $(esc(user_expr))
          framework_process($(QuoteNode(name)), user_result)
      end
  end

  # 3. Metadata-based approach
  @event_metadata Break begin
      traits = [:actor_based, :state_transition]
      watches = [:actors]
      # Users can add custom metadata
  end</code></pre><h2 id="Sample-Implementation"><a class="docs-heading-anchor" href="#Sample-Implementation">Sample Implementation</a><a id="Sample-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Sample-Implementation" title="Permalink"></a></h2><h3 id="Of-a-framework-that-enables-user-DSLs"><a class="docs-heading-anchor" href="#Of-a-framework-that-enables-user-DSLs">Of a framework that enables user DSLs</a><a id="Of-a-framework-that-enables-user-DSLs-1"></a><a class="docs-heading-anchor-permalink" href="#Of-a-framework-that-enables-user-DSLs" title="Permalink"></a></h3><pre><code class="nohighlight hljs">  # Framework provides:
    module ChronoSim

  # Low-level registration API
  function register_event_type(T::Type, config::EventConfig)
      # Store in global registry
  end

  # Composable specifications
  # This should use parametric types
  struct EventConfig{P,G,E,F}
      precondition::Union{Function, Nothing}
      generators::Vector{GeneratorSpec}
      enable::Union{Function, Nothing}
      fire::Union{Function, Nothing}
      metadata::Dict{Symbol, Any}
  end

  # Give the parametric event config a solid constructor.
  function actor_event_behavior(;
      required_state::Symbol,
      rate_field::Symbol,
      fire_action::Function
  )
      EventBehavior(
          # Specialized, inlinable functions
          (evt, physical) -&gt; getfield(physical.actors[evt.actor_idx], :state) == required_state,
          (evt, sampler, physical, when, rng) -&gt; enable!(
              sampler,
              clock_key(evt),
              getfield(getfield(physical.params[evt.actor_idx], rate_field)),
              when, when, rng
          ),
          fire_action,
          default_actor_generators()
      )
  end

  end # module

  # User&#39;s DSL:
  module ReliabilityDSL
    using ChronoSim

  macro reliability_event(name, from, to, rate_field)
      quote
          struct $(esc(name)) &lt;: SimEvent
              actor_idx::Int
          end

          config = actor_event_config(
              precondition_state = $(esc(from)),
              rate_distribution = evt -&gt; evt.physical.params[evt.actor_idx].$rate_field,
              fire_action = (evt, phys, when) -&gt; begin
                  phys.actors[evt.actor_idx].state = $(esc(to))
                  # Custom reliability logic here
              end
          )

          register_event_type($(esc(name)), config)
      end
  end

  # Clean syntax for users
  @reliability_event Break working broken fail_dist
  @reliability_event Repair broken ready repair_dist

  end # module</code></pre><h3 id="Of-an-ActorEvent{T}"><a class="docs-heading-anchor" href="#Of-an-ActorEvent{T}">Of an ActorEvent{T}</a><a id="Of-an-ActorEvent{T}-1"></a><a class="docs-heading-anchor-permalink" href="#Of-an-ActorEvent{T}" title="Permalink"></a></h3><pre><code class="nohighlight hljs">  abstract type ActorEvent{T} &lt;: SimEvent end

  # Default implementation that concrete types can override
  actor_index(evt::ActorEvent) = evt.actor_idx
  actor_collection(::Type{&lt;:ActorEvent{T}}) where T = :actors
  actor_state_field(::Type{&lt;:ActorEvent{T}}) where T = :state

  # Generic precondition - can be overridden
  function precondition(evt::E, physical) where E &lt;: ActorEvent
      actor_idx = actor_index(evt)
      checkbounds(Bool, getfield(physical, actor_collection(E)), actor_idx) || return false

      # Allow custom precondition logic
      actor_precondition(evt, physical)
  end

  # Subtype must implement this
  actor_precondition(evt::ActorEvent, physical) =
      error(&quot;Must implement actor_precondition for $(typeof(evt))&quot;)

  # Generic generators for any ActorEvent
  function generators(::Type{E}) where E &lt;: ActorEvent{T} where T
      collection = actor_collection(E)
      state_field = actor_state_field(E)

      return [
          EventGenerator(
              ToPlace,
              [collection, ℤ, state_field],
              function (f::Function, physical, actor)
                  evt = try_create_event(E, actor, physical)
                  !isnothing(evt) &amp;&amp; f(evt)
              end
          )
      ]
  end

  # Helper to create event if valid
  try_create_event(::Type{E}, actor_idx, physical) where E &lt;: ActorEvent = E(actor_idx)

  # Generic enable with rate lookup
  function enable(evt::E, sampler, physical, when, rng) where E &lt;: ActorEvent
      rate_dist = get_rate_distribution(evt, physical)
      enable_time_args = get_enable_times(evt, physical, when)
      enable!(sampler, clock_key(evt), rate_dist, enable_time_args..., rng)
  end

  # Default reenable delegates to enable
  function reenable(evt::E, sampler, physical, first_enabled, curtime, rng) where E &lt;: ActorEvent
      rate_dist = get_rate_distribution(evt, physical)
      reenable_time_args = get_reenable_times(evt, physical, first_enabled, curtime)
      enable!(sampler, clock_key(evt), rate_dist, reenable_time_args..., rng)
  end

  # Subtype must implement rate lookup
  get_rate_distribution(evt::ActorEvent, physical) =
      error(&quot;Must implement get_rate_distribution for $(typeof(evt))&quot;)

  # Default time arguments
  get_enable_times(evt::ActorEvent, physical, when) = (when, when)
  get_reenable_times(evt::ActorEvent, physical, first_enabled, curtime) = (first_enabled, curtime)</code></pre><p>And what it does to the simulation code:</p><pre><code class="nohighlight hljs"> struct Break &lt;: ActorEvent{IndividualState}
      actor_idx::Int
  end

  # Only need to specify unique behavior
  actor_precondition(evt::Break, physical) =
      physical.actors[evt.actor_idx].state == working

  get_rate_distribution(evt::Break, physical) =
      physical.params[evt.actor_idx].fail_dist

  # Custom time calculation for non-memoryless distributions
  get_enable_times(evt::Break, physical, when) =
      (when - physical.actors[evt.actor_idx].work_age, when)

  function fire!(evt::Break, physical, when, rng)
      physical.actors[evt.actor_idx].state = broken
      started_work = physical.actors[evt.actor_idx].started_working_time
      physical.actors[evt.actor_idx].work_age += when - started_work
  end

  # EndDay is even simpler
  struct EndDay &lt;: ActorEvent{IndividualState}
      actor_idx::Int
  end

  actor_precondition(evt::EndDay, physical) =
      physical.actors[evt.actor_idx].state == working

  get_rate_distribution(evt::EndDay, physical) =
      physical.params[evt.actor_idx].done_dist

  function fire!(evt::EndDay, physical, when, rng)
      physical.actors[evt.actor_idx].state = ready
      started_work = physical.actors[evt.actor_idx].started_working_time
      physical.actors[evt.actor_idx].work_age += when - started_work
  end

  # Repair
  struct Repair &lt;: ActorEvent{IndividualState}
      actor_idx::Int
  end

  actor_precondition(evt::Repair, physical) =
      physical.actors[evt.actor_idx].state == broken

  get_rate_distribution(evt::Repair, physical) =
      physical.params[evt.actor_idx].repair_dist

  function fire!(evt::Repair, physical, when, rng)
      physical.actors[evt.actor_idx].state = ready
      physical.actors[evt.actor_idx].work_age = 0.0
  end</code></pre><h3 id="Event-generation-in-particular"><a class="docs-heading-anchor" href="#Event-generation-in-particular">Event generation in particular</a><a id="Event-generation-in-particular-1"></a><a class="docs-heading-anchor-permalink" href="#Event-generation-in-particular" title="Permalink"></a></h3><p>This is a macro language to generate events. This one would create a function called <code>generators(::Type{MoveTransition})</code> that contains a list of EventGenerator objects.</p><pre><code class="nohighlight hljs">@conditionsfor MoveTransition begin
    @reactto changed(agent[i].loc) begin physical
        agent_loc = physical.agent[i].loc
        for direction in valid_directions(physical.geom, agent_loc)
            generate(MoveTransition(agent_who, direction))
        end
    end
    @reactto fired(InfectTransition(sick, healthy)) begin physical
        for neigh in neighborsof(physical, healthy)
            for nextneigh in neighborsof(physical, neigh)
            generate(InfectTransition(neigh, nextneigh))
        end
    end
end</code></pre><p>The <code>@reactto changed(agent[i].loc)</code> creates a generator that reacts <code>ToPlace</code> where the search string is <code>[:agent, ℤ, :loc]</code>. Then it makes a function closure with the arguments <code>(generate::Function, physical, i)</code> where the value passed to <code>i</code> is the <code>ℤ</code> match.</p><p>The <code>@reactto fired(InfectTransition(sick, healthy))</code> creates a generator that reacts <code>ToEvent</code> where the search string is <code>[:InfectTransition]</code> and the function closure has the arguments <code>(generate::Function, physical, sick, healthy)</code>. The values for sick and healthy are taken from the matched event.</p><h3 id="Idea-3:-The-Command-Handler-Pattern-(The-&quot;Made-Up&quot;-Idea)"><a class="docs-heading-anchor" href="#Idea-3:-The-Command-Handler-Pattern-(The-&quot;Made-Up&quot;-Idea)">Idea 3: The Command-Handler Pattern (The &quot;Made Up&quot; Idea)</a><a id="Idea-3:-The-Command-Handler-Pattern-(The-&quot;Made-Up&quot;-Idea)-1"></a><a class="docs-heading-anchor-permalink" href="#Idea-3:-The-Command-Handler-Pattern-(The-&quot;Made-Up&quot;-Idea)" title="Permalink"></a></h3><p>What if we get rid of enable and rate functions as top-level concepts for the user and borrow from patterns like CQRS/Event Sourcing?</p><ul><li><p>The Concept: The simulation loop is driven by Commands.</p><ol><li>State is your physical state.</li><li>A Command is a data struct representing an intent to cause an event (e.g., TryToBreak(actor_idx)). Users can  dispatch commands at any time.</li><li>A Handler is a function handle(command, state). It looks at the command and the current state and returns  zero or more potential (Event, Distribution) tuples. For TryToBreak(1), the handler checks if actor 1 is  working and, if so, returns (BreakOccurred(1), fail_dist). This single function effectively combines the  &quot;generator&quot;, &quot;precondition&quot;, and &quot;rate&quot; logic.</li><li>An Event is a data struct representing something that happened (e.g., BreakOccurred(actor_idx)).</li><li>The <code>fire!</code> function is replaced by a pure &quot;reducer&quot; function: apply(event, state) -&gt; new_state.</li></ol><p>The main loop would look like:</p><ol><li>Collect all possible Commands that could be issued in the current state.</li><li>Run them through their Handlers to get a list of possible (Event, Distribution) pairs.</li><li>Pass this list to CompetingClocks.jl to sample the next Event.</li><li>apply the chosen event to the state.</li><li>Repeat.</li></ol></li><li><p>How it Simplifies:</p><ul><li>Conceptual Clarity: The flow is very clear: you issue a Command, a Handler translates it into a potential   Event, the sampler picks one, and an apply function enacts it. The roles are extremely well-defined.</li><li>It <em>almost</em> gets rid of event keys: The sampler would work with Event structs directly. The clock_key could be   generated implicitly from the event&#39;s type and data. You wouldn&#39;t need a separate &quot;key&quot; struct.</li><li>It combines Generator, Enable, and Rate: The Handler function serves all three purposes in one go.</li></ul></li><li><p>This takes the five parts of each event and spreads them across the simulation. It looks more like a traditional simulation. In that case, how is this simulation style, splitting the event enabling from the state, so different from simulation where, during the handling of a command, new events are created? What is the intrinsic different, and if there is an advantage to splitting events and state, how do we realize that advantage while retaining the narrative structure of traditional simulation styles? Or how do we realize the advantages of avoiding that narrative structure? Where is the payoff?</p></li></ul><p>This is a more functional approach that radically simplifies the user&#39;s conceptual model, even if it adds a few new concepts (Command, Handler).</p><p>The payoff is that this purity and separation are precisely what unlocks the advanced capabilities you want and makes your &quot;propagator&quot; vision a reality.</p><ol><li><p>The Event Log Becomes a First-Class Citizen: Because the apply function is pure (state, event) -&gt; new<em>state, the  entire simulation history can be represented as new</em>state = apply(event<em>n, ... apply(event</em>1, apply(event<em>0,  initial</em>state))). The sequence of events [event<em>0, event</em>1, ..., event_n] is a complete, tangible, and replayable  log of what happened. This isn&#39;t just a printout; it&#39;s a data structure you can analyze.</p></li><li><p>Likelihood Calculation Becomes Trivial: With the event log as data, calculating the likelihood of that specific  trajectory is straightforward. At each step k, you know exactly which possibilities the handle function presented  to the sampler and which event_k was chosen. The total likelihood is the product of those individual  probabilities.</p></li><li><p>Time-Travel, Counterfactuals, and Debugging: This is the killer feature.</p><ul><li>Want to simulate backwards? You have the whole event history.</li><li>Want to know &quot;what if&quot;? Go back to state_k, inspect the possibilities generated by the handlers, and manually   run the propagator with a different event choice. You can fork reality at any point.</li><li>Debugging is transformed. A bug is no longer a mysterious state corruption. It&#39;s an apply function that   returned the wrong new<em>state for a given (event, old</em>state). You can test your apply reducers like any other   pure function, completely isolated from the complexity of the simulation loop.</li></ul></li><li><p>Enforced Separation of Concerns: Your commitment to separating the model from the sampler is now enforced by the  function signatures. The model code (handlers and reducers) literally cannot access the sampler. This makes the  system architecture incredibly clean and robust.</p></li></ol><h3 id="It-looks-like-the-AI-caught-on-to-my-plan:"><a class="docs-heading-anchor" href="#It-looks-like-the-AI-caught-on-to-my-plan:">It looks like the AI caught on to my plan:</a><a id="It-looks-like-the-AI-caught-on-to-my-plan:-1"></a><a class="docs-heading-anchor-permalink" href="#It-looks-like-the-AI-caught-on-to-my-plan:" title="Permalink"></a></h3><p>A Possible Reframing</p><p>What if the mental model were:</p><p>User defines: ModelSpec     ├── State type (plain Julia struct, no ObservedArray needed)     ├── Event types     └── Event interface methods (fire!, enable, precondition)</p><p>ChronoSim provides: Execution strategies     ├── ForwardSimulation (adds generators, ObservedState, DependencyNetwork)     ├── LikelihoodReplay (uses core model only)     └── GenDistribution / TuringModel wrappers</p><h3 id="Hooks!"><a class="docs-heading-anchor" href="#Hooks!">Hooks!</a><a id="Hooks!-1"></a><a class="docs-heading-anchor-permalink" href="#Hooks!" title="Permalink"></a></h3><p>ChronoSim.jl runs simulations forward but doesn&#39;t have hooks for:</p><ul><li>Pausing at decision points</li><li>Branching into multiple rollouts</li><li>Comparing outcomes and selecting actions</li></ul><p>And we really need to make clear this isn&#39;t just about forward simulation.</p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reference/">« Reference</a><a class="docs-footer-nextpage" href="../event_update/">Event Updates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 6 December 2025 15:06">Saturday 6 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
