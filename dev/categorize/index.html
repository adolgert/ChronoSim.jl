<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Category of Simulation · ChronoSim.jl</title><meta name="title" content="Category of Simulation · ChronoSim.jl"/><meta property="og:title" content="Category of Simulation · ChronoSim.jl"/><meta property="twitter:title" content="Category of Simulation · ChronoSim.jl"/><meta name="description" content="Documentation for ChronoSim.jl."/><meta property="og:description" content="Documentation for ChronoSim.jl."/><meta property="twitter:description" content="Documentation for ChronoSim.jl."/><meta property="og:url" content="https://adolgert.github.io/ChronoSim.jl/categorize/"/><meta property="twitter:url" content="https://adolgert.github.io/ChronoSim.jl/categorize/"/><link rel="canonical" href="https://adolgert.github.io/ChronoSim.jl/categorize/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ChronoSim.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">ChronoSim</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../not_chrono/">Why Not Hand Made</a></li><li><a class="tocitem" href="../whatitis/">What It Does</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../simulation_state/">Simulation State</a></li><li class="is-active"><a class="tocitem" href>Category of Simulation</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Exact,-Stochastic,-Continuous-time"><span>Exact, Stochastic, Continuous-time</span></a></li><li><a class="tocitem" href="#The-Generalized-Semi-Markov-Process"><span>The Generalized Semi-Markov Process</span></a></li><li><a class="tocitem" href="#Using-Anderson-and-Kurtz-to-Pull-Out-Samplers"><span>Using Anderson and Kurtz to Pull Out Samplers</span></a></li><li><a class="tocitem" href="#Actuarial-Simulation-and-Reliability-Simulation"><span>Actuarial Simulation and Reliability Simulation</span></a></li><li><a class="tocitem" href="#Generalized-Stochastic-Petri-Nets"><span>Generalized Stochastic Petri Nets</span></a></li><li><a class="tocitem" href="#Letting-go-of-some-rules"><span>Letting go of some rules</span></a></li><li><a class="tocitem" href="#Agent-based"><span>Agent-based</span></a></li><li><a class="tocitem" href="#Formal-methods"><span>Formal methods</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><span class="tocitem">Development</span><ul><li><a class="tocitem" href="../plan/">Plan</a></li><li><a class="tocitem" href="../event_update/">Event Updates</a></li><li><a class="tocitem" href="../architecture_diagram/">Architecture</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Category of Simulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Category of Simulation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/ChronoSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/ChronoSim.jl/blob/main/docs/src/categorize.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Category-of-Simulation"><a class="docs-heading-anchor" href="#Category-of-Simulation">Category of Simulation</a><a id="Category-of-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Category-of-Simulation" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>The ChronoSim.jl simulation framework doesn&#39;t fit exactly into some of the major categories of simulation. For those who want to understand ChronoSim.jl in relation to other simulation styles, and for those who think about how we express simulations, this section places ChronoSim.jl in the context of known simulation styles.</p><h2 id="Exact,-Stochastic,-Continuous-time"><a class="docs-heading-anchor" href="#Exact,-Stochastic,-Continuous-time">Exact, Stochastic, Continuous-time</a><a id="Exact,-Stochastic,-Continuous-time-1"></a><a class="docs-heading-anchor-permalink" href="#Exact,-Stochastic,-Continuous-time" title="Permalink"></a></h2><p>The sampling algorithms used are exact, continuous-time sampling. Wikipedia calls these algorithms <a href="https://en.wikipedia.org/wiki/Gillespie_algorithm">Gillespie Algorithms</a>, but I would argue that is a misnomer because a simple heap-based first-to-fire style of sampling is an exact sampling of one of these systems, and this method was known well before Gillespie. It was known before Doob&#39;s algorithm, which was also before Gillespie.</p><h2 id="The-Generalized-Semi-Markov-Process"><a class="docs-heading-anchor" href="#The-Generalized-Semi-Markov-Process">The Generalized Semi-Markov Process</a><a id="The-Generalized-Semi-Markov-Process-1"></a><a class="docs-heading-anchor-permalink" href="#The-Generalized-Semi-Markov-Process" title="Permalink"></a></h2><p>Simulations in ChronoSim.jl define a stochastic process. The closest analog to that stochastic process is a Generalized Semi-Markov Process (GSMP). A GSMP defines a set of states, <span>$p_i$</span>, indexed by <span>$i$</span>. It defines a set of stochastic processes where each stochastic process depends on a subset of the <span>$p_i$</span>. We would now call these individual counting processes. In the GSMP, each counting process proceeds according to a clock rate, which is the hazard rate of a distribution.</p><p>Each event in an GSMP changes a subset of the state. If you zoom out, you can ask how the whole state, all of the <span>$p_i$</span>, change when a single process fires. This defines a transition for the system as a whole. Zooming out like this shows the GSMP defines a semi-Markov process, which is a Markov process that doesn&#39;t limit the distribution of times between jumps to being Exponentially-distributed.</p><p>The state of a GSMP is its <em>physical states</em>, the <span>$p_i$</span>, and the state of each clock, which is the time it has run down. ChronoSim borrows this name &quot;physical state.&quot;</p><p>The GSMP was a fantastic invention in its day. It used the crutch of the substates, <span>$p_i$</span>, to give the processes a way to be long-lived when other processes in the system fired. The dependency graph between substates and transitions became what Gibson and Bruck called a reaction graph in the Next Reaction method in 2000.</p><h2 id="Using-Anderson-and-Kurtz-to-Pull-Out-Samplers"><a class="docs-heading-anchor" href="#Using-Anderson-and-Kurtz-to-Pull-Out-Samplers">Using Anderson and Kurtz to Pull Out Samplers</a><a id="Using-Anderson-and-Kurtz-to-Pull-Out-Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Anderson-and-Kurtz-to-Pull-Out-Samplers" title="Permalink"></a></h2><p>There is a book by Anderson and Kurtz, called &lt;i&gt;Stochastic Analysis of Biochemical Systems&lt;/i&gt;, Springer 2015, that clarifies what defines a minimal continuous-time process and its sampler. In that book, they take all of the history of how to define the state of a continuous-time stochastic simulation and throw it out the window. All that&#39;s left is the sequence of events and times that record jumps in a set of counting processes. They call it a &quot;filtration&quot; in this probabilistic context.</p><p>What was important for ChronoSim.jl is that Anderson and Kurtz showed that all of the sampling machinery can be pulled out of the simulation. Only the states and times of each counting process need to be known to the sampler. That&#39;s enough to make a complete, highly-optimized sampler in CompetingClocks.jl while pulling out into the ChronoSim framework the logic of what happens when an event fires.</p><h2 id="Actuarial-Simulation-and-Reliability-Simulation"><a class="docs-heading-anchor" href="#Actuarial-Simulation-and-Reliability-Simulation">Actuarial Simulation and Reliability Simulation</a><a id="Actuarial-Simulation-and-Reliability-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Actuarial-Simulation-and-Reliability-Simulation" title="Permalink"></a></h2><p>Both actuaries and reliability modelers pay close attention to whether simulations accurately reflect measured and estimated hazard rates of events. Both bodies of literature contain closed-form solutions for multi-state simulations with time-varying hazard rates. These fields focus less on engineering methods for simulation.</p><p>ChronoSim.jl is an attempt to be the inverse of survival analysis. The goal of the care in defining events and distributions in time is to be faithful to how hazard rates depend on state. We&#39;re taking engineering approaches and bringing the statistical tools to the fore.</p><h2 id="Generalized-Stochastic-Petri-Nets"><a class="docs-heading-anchor" href="#Generalized-Stochastic-Petri-Nets">Generalized Stochastic Petri Nets</a><a id="Generalized-Stochastic-Petri-Nets-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Stochastic-Petri-Nets" title="Permalink"></a></h2><p>The Generalized Stochastic Petri Net (GSPN) was popular in the 1990&#39;s and more popular after 2000 when Gibson and Bruck&#39;s work (and the uncited work of Kurtz) contributed to the speed of sampling.</p><p>A GSPN is a set of Places where a place can hold one or more Tokens. A token can be represent presence or absence at a place, or a token can be &quot;colored,&quot; which means it carries state. Think of it as a struct. The placement of tokens on places defines a Marking, and a Marking defines the physical state of the system. Transitions take tokens as input and produce tokens. They specify which tokens they consume and produce through a graph that connects transitions to places and an annotation on that graph indicating how many tokens are consumed or produced from each place.</p><p>You can use a GSPN to define a chemical simulation. It doesn&#39;t take much work. You need to use a specific formula for how the rate of a reaction (transition) depends on the number of molecules (tokens) of each chemical species (place).</p><p>Theoreticians love GSPN because the whole graph of the simulation is laid bare. It&#39;s created and initialized before the simulation runs. It&#39;s a simple mathematical trick to calculate <em>reachability</em> of a future state from the current state. For instance, given the current state, it is possible for the system to arrive in a state that is a failure mode? It&#39;s great for safety guarantees.</p><p>The big problem with GSPN is that they are burdensome to create. To quote Bryan Grenfell, &quot;We tried that back then and it was awful.&quot; If you create a model with individuals stratified by age, by sex, by location, and by disease state, you&#39;ve created a combinatorially large simulation with lots of careful coding required.</p><h2 id="Letting-go-of-some-rules"><a class="docs-heading-anchor" href="#Letting-go-of-some-rules">Letting go of some rules</a><a id="Letting-go-of-some-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Letting-go-of-some-rules" title="Permalink"></a></h2><p>If we agree that we don&#39;t necessarily need to compute an exact reachability graph for a simulation, then we can let go of a lot of the pain of a GSPN.</p><p>ChronoSim.jl builds a GSPN-style bipartite graph of places and events on the fly as it computes a simulation. It watches the <code>precondition()</code> functions to record what state a event depends on. It watches the <code>enable()</code> functions to record what events the rate of a event depends on. When a event fires, the list of changes to state are compared against the list of dependencies of all existing, currently-enabled events in order to update their enabling and rates. ChronoSim.jl tries to side-step the pain points of GSPN by making generation of dependencies <em>dynamic.</em></p><p>It also becomes easy to implement immediate events. These are events that fire at the same time as the timed event. If we think of the system as one semi-Markov process, the transition of that semi-Markov state is calculated from the timed event and all immediate events together.</p><p>In a GSPN, the enabling of transitions depends only on the state. That&#39;s the only way to do it. If we instead take Anderson and Kurtz as our guide, it&#39;s clear that the events are the least, complete description of the history of the system. There is no reason not to include the ability to trigger the next event based on the previous event, so that is included in ChronoSim.jl as a possibility.</p><h2 id="Agent-based"><a class="docs-heading-anchor" href="#Agent-based">Agent-based</a><a id="Agent-based-1"></a><a class="docs-heading-anchor-permalink" href="#Agent-based" title="Permalink"></a></h2><p>From the perspective above, agent-based simulation can be done with any of the above methods. What makes a simulation agent-based is the imposition of the invariants on the system. For instance, if we make a rule that a rabbit is in a field, the invariant that makes the simulation agent-based would be that the rabbit doesn&#39;t disappear and reappear.</p><p>Whether a simulation made with ChronoSim.jl is agent-based depends on what you define in the simulation. It&#39;s not intrinsic to the simulation framework. It&#39;s also not difficult to implement.</p><h2 id="Formal-methods"><a class="docs-heading-anchor" href="#Formal-methods">Formal methods</a><a id="Formal-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Formal-methods" title="Permalink"></a></h2><p>The way ChronoSim.jl defines events looks so much like <a href="https://learntla.com/">TLA+</a> that it looks like a transliteration. It started from Anderson and Kurtz&#39;s probability theory, not from TLA+. The convergence is just a sign of similar good taste.</p><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>ChronoSim.jl is</p><ul><li>Exact, stochastic, continuous-time sampling.</li><li>Process-interaction models, maybe more properly called state-mediated.</li><li>With time-varying hazards and immediate transitions.</li><li>Generating transitions dynamically.</li></ul><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simulation_state/">« Simulation State</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 28 August 2025 14:07">Thursday 28 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
